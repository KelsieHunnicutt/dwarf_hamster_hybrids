---
title: "Mouse Hybrid Testes RNASeq"
author: "Kelsie E. Hunnicutt"
output:
  html_document: default
  pdf_document: default
---

<h3>Loading libraries and importing data</h3>
```{r setup}
#load packages; make sure these are installed on your machine
suppressMessages(library("edgeR")) #for differential expression analysis
suppressMessages(library("limma")) #for differential expression analysis
suppressMessages(library("ComplexHeatmap")) #for heatmap generation
suppressMessages(library("reshape2")) #for creating the conditions dataframe 
suppressMessages(library("data.table")) #for creating and manipulating data frames 
suppressMessages(library("ggplot2")) #for data visualizing
suppressMessages(library("vegan")) # for decostand count normalization method
suppressMessages(library("matrixStats")) #for calculating median/max values across rows of data frames
suppressMessages(library("ggbeeswarm")) #for offsetting overlapping points in boxplots and violins
suppressMessages(library("tidyr")) #for transforming data frames from wide to long format or long to wide format
suppressMessages(library("FSA")) #for dunn's test
suppressMessages(library("magick")) #for better Heatmap rasterization
suppressMessages(library("ggsignif")) #add significance annotation data to ggplot graphs
suppressMessages(library("dplyr")) #for recoding when doing orthology assignments
suppressMessages(library("knitr")) #to display tables with kable
suppressMessages(library("ggalluvial")) #for alluvial diagrams
suppressMessages(library("dendextend")) #for dendogram plotting
suppressMessages(library("cowplot")) # for multipanel plot organization

#set working directory and get today's date; set to the directory corresponding to where you downloaded this repository
knitr::opts_knit$set(root.dir = "your_working_directory")
unlink(".RData")
all_labels()
options(scipen = 999)

todays_date <- gsub("^[A-z][A-z][A-z] *([A-z][A-z][A-z]) *([0-9]+).*20([0-9][0-9])", "\\2\\1\\3", date())
todays_date

sessionInfo()
```

```{r import-data}
#select a counts file then read in raw counts; no multimapping was allowed for the main text figures but the multi-mapped files are provided for both dwarf hamster and mouse if desired; general patterns are the same
count_file.path <- "input_data/SingleCell_no-multi_20Jun20_suspenders_featureCounts.csv"
count_data <- read.table(count_file.path, header = TRUE, row.names=NULL, sep = "\t")

#select a metadata file then read in info
metadata_file.path <- "input_data/SingleCell_no-multi_20Jun20_suspenders_featureCounts.csv.summary"
metadata <- read.table(metadata_file.path, header = TRUE, row.names=1, sep = "\t")

#load annotation file for either all genes or just protein coding
#this file was manipulated with sed from the ensembl gtf file 
annotations <- read.table("input_data/ensembl_allgenes_mm38_96_chrs.txt", header = TRUE, stringsAsFactors = FALSE, row.names = c(1))
annotations <- annotations[order(rownames(annotations)), ]
setorder(annotations, chr, start)
annotations$gene_name <- annotations$gene
annotations$gene <- rownames(annotations)

annotations$X_category <- "Auto"
annotations[annotations$chr == "X",]$X_category <- "X"
annotations[annotations$chr == "Y",]$X_category <- "Y"

head(annotations)

chrom_key <- read.csv("input_data/mmus_chromosomes.csv")

#parsing out gene lengths to add to the annotation file
genes_list <- count_data[1:6]
genes_list <- genes_list[genes_list$Geneid %in% rownames(annotations),]
rownames(genes_list) <- genes_list$Geneid
genes_list <- genes_list[rownames(annotations), ]
annotations <- cbind("Length" = genes_list$Length, annotations)
```

<h3>Reformatting condition names</h3>
```{r fixing-sample-names, include=FALSE}
#edit metadata to include condition type (condition_name) for each sample
#transpose, rename columns, delete redundant row
metadata <- t(metadata)
head(rownames(metadata))
rownames(metadata) <- gsub(".WT.*.bam","-WT", rownames(metadata))
rownames(metadata) <- gsub(".SP.*.bam","-SP", rownames(metadata))
rownames(metadata) <- gsub(".LZ.*.bam","-LZ", rownames(metadata))
rownames(metadata) <- gsub(".DIP.*.bam","-DIP", rownames(metadata))
rownames(metadata) <- gsub(".RS.*.bam","-RS", rownames(metadata))
rownames(metadata)  <- gsub("..*WWLL\\.","DomP-", rownames(metadata))
rownames(metadata)  <- gsub("..*LLWW\\.","DomP-", rownames(metadata))
rownames(metadata)  <- gsub("..*PPCC\\.","MusP-", rownames(metadata))
rownames(metadata)  <- gsub("..*CCPP\\.","MusP-", rownames(metadata))
rownames(metadata)  <- gsub("..*LLPP\\.","DFHyb-", rownames(metadata))
rownames(metadata)  <- gsub("..*PPLL\\.","MSHyb-", rownames(metadata))
head(rownames(metadata))

#split status into meaningful info (which species/hybrid, individual ID, and stage of spermatogenesis) then create condition names for DE analysis later and bind data frame to metadata
conditions_df <- colsplit(row.names(metadata), pattern = "-", names = c("cross","male_number","stage"))
conditions_df$sample_name <- paste(conditions_df$cross, conditions_df$male_number, conditions_df$stage, sep = ".")
conditions_df$condition_name <- paste(conditions_df$cross, conditions_df$stage, sep = "-") 
metadata <- cbind(metadata, conditions_df)

#in preparation for DGE creation, make a dataframe of just gene name and counts
just_counts <- count_data[7:dim(count_data)[2]]
row.names(just_counts) <- count_data[,1]
#match order of count dataframe to annotations
just_counts <- just_counts[rownames(annotations), ]
head(colnames(just_counts))

#match just_counts IDs with metadata IDs (i.e. remove extraneous info from featureCount filenames)
colnames(just_counts) <- gsub(".WT.*.bam","-WT", colnames(just_counts))
colnames(just_counts) <- gsub(".SP.*.bam","-SP", colnames(just_counts))
colnames(just_counts) <- gsub(".LZ.*.bam","-LZ", colnames(just_counts))
colnames(just_counts) <- gsub(".DIP.*.bam","-DIP", colnames(just_counts))
colnames(just_counts) <- gsub(".RS.*.bam","-RS", colnames(just_counts))
colnames(just_counts)  <- gsub("..*WWLL\\.","DomP-", colnames(just_counts))
colnames(just_counts)  <- gsub("..*LLWW\\.","DomP-", colnames(just_counts))
colnames(just_counts)  <- gsub("..*PPCC\\.","MusP-", colnames(just_counts))
colnames(just_counts)  <- gsub("..*CCPP\\.","MusP-", colnames(just_counts))
colnames(just_counts)  <- gsub("..*LLPP\\.","DFHyb-", colnames(just_counts))
colnames(just_counts)  <- gsub("..*PPLL\\.","MSHyb-", colnames(just_counts))
head(colnames(just_counts))

#remove fertile hybrids from analysis
just_counts <- just_counts[,grep("DFHyb", colnames(just_counts), invert = TRUE)]
metadata <- metadata[grep("DFHyb", metadata$cross, invert = TRUE),]

#remove whole testes samples which are not used in hybrid analyses
just_counts <- just_counts[,grep("WT", colnames(just_counts), invert = TRUE)]
metadata <- metadata[grep("WT", rownames(metadata), invert = TRUE),]
```

<h3>Color Set-Up</h3>
```{r color-setup}
#coloring indicates stage and colors used here are used throughout
#Red = spermatogonia, Yellow = leptotene-zygotene, Green = diplotene, and Blue = round spermatids
sp_color <- "#E07A5F"
sp_color_dark <- "#D85531"
sp_color_darkest <- "#AB3F21"
lz_color <- "#EEBC6D"
lz_color_dark <- "#E7A336"
lz_color_darkest <- "#DB911A"
dip_color <- "#81B29A"
dip_color_dark <- "#5D987B"
dip_color_darkest <- "#46725D"
rs_color <- "#6C719D"
rs_color_dark <- "#3D405B"
rs_color_darkest <- "#292B3D"

gray_1 <- "#EBEBEB"
gray_2 <- "#D6D6D6"
gray_3 <- "#C2C2C2"
gray_4 <- "#999999"
gray_5 <- "#646464"
gray_6 <- "#525252"
gray_7 <- "#474747"

#combining colors into vectors based on the color saturation
color_list <- c(SP = sp_color, 
                LZ = lz_color, 
                DIP = dip_color, 
                RS = rs_color)
color_list_dark <- c(SP = sp_color_dark, 
                     LZ = lz_color_dark, 
                     DIP = dip_color_dark, 
                     RS = rs_color_dark)
color_list_darkest <- c(SP = sp_color_darkest, 
                        LZ = lz_color_darkest, 
                        DIP = dip_color_darkest, 
                        RS = rs_color_darkest)

#a function to convert a vector from raw p-values to significance symbols
sig_conversion <- function(misc_dataframe) {
  triple <- misc_dataframe <= 0.001
  double <- misc_dataframe >= 0.001 & misc_dataframe<0.01 
  single <- misc_dataframe >= 0.01 & misc_dataframe<0.05 
  nonsig <- misc_dataframe >= 0.05 
  misc_dataframe[single] <- "*"
  misc_dataframe[double] <- "**"
  misc_dataframe[triple] <- "***"
  misc_dataframe[nonsig] <- "n.s."
  return(misc_dataframe)
}

#a function for calculating standard error of the mean from an input vector of data
calculate_sem <- function(vector_of_interest) {
  sd(vector_of_interest)/sqrt(length((vector_of_interest)))
}

#graphing parameters
point_size <- 0.5
text_size <- 6
boxplot_width <- 0.1
vjust_value <- 0.8
boxplot_lwd <- 0.2
axis_size <- 0.2
sigText_size <- 2
sigLine_size <- 0.25

#set figure export dimensions; MBE guidelines are single column width = 8.2 cm/3.25 inches; 2 columns = 16.9 cm/6.75 inches; depth = 24 cm/9.25 inches.
half_plot_width <- 3.25
full_plot_width <- 6.75
half_plot_height <- 3
full_plot_height <- 6
```

<h3>Settings</h3>
```{r settings-and-base-expression-stats}
#set thresholds for determining if a gene is "expressed"; needs to have an rpkm of at least 1 in at least 3 replicates
rpkm.cutoff <- 1
min.reps <- 3

#methods used for normalizing data; RLE used in manuscript
norm.method <- "RLE"
#norm.method <- "TMM"

#should figures should be written to files or plotted in R?
exportFigs <- TRUE

#printing for record keeping purposes
paste("countfile used:", count_file.path, sep = " ")
paste("metadata file used:", metadata_file.path, sep = " ")

#printing for record keeping purposes
print("Parameters Used:")
paste("All genes have a minimum rpkm of:", rpkm.cutoff, sep = " ")
paste("A gene must be expressed in at least", min.reps, "samples", sep = " ")
paste("Counts are normalized with:", norm.method, sep = " ")

#define orders of datasets, stages, and genotypes for factor purposes
#MusP = parental M. m. musculus, MSHyb = F1 M. m. musculus x M. m. domesticus males, DomP = parental M. m. domesticus
stages <- c("SP", "LZ", "DIP", "RS")
genotypes <- c("MusP","DomP", "MSHyb")

#printing for record keeping purposes then cleanup unused values
paste("countfile used:", count_file.path, sep = " ")
paste("metadata file used:", metadata_file.path, sep = " ")
rm(count_file.path, metadata_file.path)

#printing for record keeping purposes
print("Parameters Used:")
paste("All expressed genes have a minimum rpkm of:", rpkm.cutoff, sep = " ")
paste("An expressed gene must be expressed in at least", min.reps, "samples", sep = " ")
paste("Counts are normalized with:", norm.method, sep = " ")

#make DGEs for sorted cell population data (i.e. exclude whole testes samples)
dgeMouse <- DGEList(just_counts, genes=annotations, group=metadata$condition_name)
paste("Expressed genes in sorted cell dataset (no cutoffs):", nrow(dgeMouse), sep = " ")

#create function normalize_dge which reads in a dge, applies the rpkm and minimum replicate cutoffs for determining if a gene is expressed, then it re-normalizes the data using the normalization method specified above
normalize_dge <- function(dge_name) {
  keep <- rowSums(rpkm(dge_name) >= rpkm.cutoff) >= min.reps 
  dge_name <- dge_name[keep, keep.lib.sizes=FALSE]
  dge_name <- calcNormFactors(dge_name, method = norm.method)
}

#filter DGEs with genes meeting minimum requirements using normalize_dge function defined above; Dev throughout refers to dataset consisting of sorted developmental stages (i.e., not including whole testes samples)
dgeMouse <- normalize_dge(dgeMouse)

#print expressed genes for each DGE- post filter
paste("Expressed genes in sorted cell dataset (with filter):", nrow(dgeMouse), sep = " ")
```
<h3>Catogorize expressed genes by chromosome</h3>
```{r categorize-genes-by-chromosome}
#define annotation subsets for autosomal, X-linked, and Y-linked genes
Auto_genes <- annotations[annotations$X_category == "Auto",]$gene
X_genes <- annotations[annotations$X_category == "X",]$gene
Y_genes <- annotations[annotations$X_category == "Y",]$gene

filtered_allAuto_genes <- Auto_genes[Auto_genes %in% dgeMouse$genes$gene]
filtered_justX_genes <- X_genes[X_genes %in% dgeMouse$genes$gene]
filtered_justY_genes <- Y_genes[Y_genes %in% dgeMouse$genes$gene]

#subset count data into counts for genes on all Autosomes, on the X, and the subsets of the X (counts are not normalized)
just_Auto_counts <- just_counts[rownames(just_counts) %in% Auto_genes,]
just_X_counts <- just_counts[rownames(just_counts) %in% X_genes,]
just_Y_counts <- just_counts[rownames(just_counts) %in% Y_genes,]

#summary line
paste("Annotation stats:", length(rownames(annotations)), "Auto_genes:", length(Auto_genes), "X_genes:", length(X_genes), "Y_genes:", length(Y_genes), sep = " ")

#number of expressed genes in combined data
mouse_numbers <- paste("total_genes:", length(dgeMouse$genes$gene), 
                       "; Auto_genes:", sum(dgeMouse$genes$gene %in% Auto_genes), 
                       "; X_genes:", sum(dgeMouse$genes$gene %in% X_genes), 
                       "; Y_genes:", sum(dgeMouse$genes$gene %in% Y_genes), 
                       "; x/a=", round(sum(dgeMouse$genes$gene %in% X_genes)/
                                         length(dgeMouse$genes$gene)*100, 2),  
                       sep = " ")

kable(rbind(c(length(rownames(annotations)), 
              length(Auto_genes), 
              length(X_genes), 
              length(Y_genes), 
              round(100*length(X_genes)/
                      length(rownames(annotations)), 2)),
            c(length(dgeMouse$genes$gene), 
              sum(dgeMouse$genes$gene %in% Auto_genes), 
              sum(dgeMouse$genes$gene %in% X_genes), 
              sum(dgeMouse$genes$gene %in% Y_genes), 
              round(sum(dgeMouse$genes$gene %in% X_genes)/
                      length(dgeMouse$genes$gene)*100,2))), 
      "simple") 

paste("Total expressed genes:", mouse_numbers)
#cleanup
rm(mouse_numbers)
```

<h3>Make all subsetted DGEs for MDSplots using all genes</h3>
```{r dge-subsets}
#make all subsetted DGEs for MDSplots by specifying which countfiles, annotations, and grouping info to use for each dge then normalize that dge with the above normalize_dge function

#subsetted by spermatogenic stage
dgeSP <- DGEList(just_counts[,grep("SP",colnames(just_counts))], genes=annotations, group=grep("SP",metadata$condition_name, value = TRUE))
dgeSP <- normalize_dge(dgeSP)

dgeLZ <- DGEList(just_counts[,grep("LZ",colnames(just_counts))], genes=annotations, group=grep("LZ",metadata$condition_name, value = TRUE))
dgeLZ <- normalize_dge(dgeLZ)

dgeDIP <- DGEList(just_counts[,grep("DIP",colnames(just_counts))], genes=annotations, group=grep("DIP",metadata$condition_name, value = TRUE))
dgeDIP <- normalize_dge(dgeDIP)

dgeRS <- DGEList(just_counts[,grep("RS",colnames(just_counts))], genes=annotations, group=grep("RS",metadata$condition_name, value = TRUE))
dgeRS <- normalize_dge(dgeRS)

#subsetted by genotype
dgeDomP <- DGEList(just_counts[,grep("DomP.*-[D,L,S,R]",colnames(just_counts))], genes=annotations, group=grep("DomP-[D,L,S,R]",metadata$condition_name, value = TRUE))
dgeDomP <- normalize_dge(dgeDomP)

dgeMSHyb <- DGEList(just_counts[,grep("MSHyb.*-[D,L,S,R]",colnames(just_counts))], genes=annotations, group=grep("MSHyb-[D,L,S,R]",metadata$condition_name, value = TRUE))
dgeMSHyb <- normalize_dge(dgeMSHyb)

dgeMusP <- DGEList(just_counts[,grep("MusP.*-[D,L,S,R]",colnames(just_counts))], genes=annotations, group=grep("MusP-[D,L,S,R]",metadata$condition_name, value = TRUE))
dgeMusP <- normalize_dge(dgeMusP)

#sex chromosome/autosome DGEs
dgeX <- DGEList(just_X_counts, 
                genes=annotations[annotations$gene %in% X_genes,], 
                group=metadata$condition_name)
dgeX <- normalize_dge(dgeX)

dgeY <- DGEList(just_Y_counts, 
                genes=annotations[annotations$gene %in% Y_genes,], 
                group=metadata$condition_name)
dgeY <- normalize_dge(dgeY)

dgeAuto <- DGEList(just_Auto_counts, 
                   genes=annotations[annotations$gene %in% Auto_genes,], 
                   group=metadata$condition_name)
dgeAuto <- normalize_dge(dgeAuto)
```

<h3>Define the base order of the heatmap columns</h3>
```{r heatmap-settings}
#formatting metadata
metadata$cross <- factor(metadata$cross, levels = genotypes)
genotype_order <- seq(1,3)[metadata$cross]
metadata$stage <- factor(metadata$stage, levels = stages)
stage_order <- seq(1,4)[metadata$stage]

#heatmap order for all samples from Mouse dataset and just sorted cells
Full_heatmap_order <- rownames(metadata[order(stage_order, genotype_order),])
rm(genotype_order, stage_order)

#heatmap order by genotype
MusP_heatmap_order <- grep("MusP", Full_heatmap_order, value = TRUE)
DomP_heatmap_order <- grep("DomP", Full_heatmap_order, value = TRUE)
MSHyb_heatmap_order <- grep("MSHyb", Full_heatmap_order, value = TRUE)

#heatmap order by stage
SP_heatmap_order <- grep("SP", Full_heatmap_order, value = TRUE)
LZ_heatmap_order <- grep("LZ", Full_heatmap_order, value = TRUE)
DIP_heatmap_order <- grep("DIP", Full_heatmap_order, value = TRUE)
RS_heatmap_order <- grep("RS", Full_heatmap_order, value = TRUE)

#define color palette for all heatmaps
colfunc <- colorRampPalette(c("#F6F3F3", "#231A1A"))
browns <- colfunc(255)
rm(colfunc)
```

<h3>Set up CPM, rpkm, and Normalized FPKM data frames - not subsetted</h3>
```{r create-count-dfs-not-subsetted}
#counts per million dataframes for the whole dataset and by sex chromosome
cpm.log <- cpm(dgeMouse, log = TRUE)
cpm_justX.log <- subset(cpm.log, rownames(cpm.log) %in% X_genes)
cpm_justY.log <- subset(cpm.log, rownames(cpm.log) %in% Y_genes)
cpm_allAuto.log <- subset(cpm.log, rownames(cpm.log) %in% Auto_genes)

#reads of kilobase of transcript, per million mapped reads (rpkm) dataframes for each of the three datasets (Mouse, dev, wt) and for each by sex chromosome
rpkm.nonLog <- as.data.frame(rpkm(dgeMouse, normalized.lib.sizes = TRUE, log = FALSE))
rpkm_justX.nonLog <- subset(rpkm.nonLog, rownames(rpkm.nonLog) %in% X_genes)
rpkm_justY.nonLog <- subset(rpkm.nonLog, rownames(rpkm.nonLog) %in% Y_genes)
rpkm_allAuto.nonLog <- subset(rpkm.nonLog, rownames(rpkm.nonLog) %in% Auto_genes)

#log2 reads of kilobase of transcript, per million mapped reads (log2(rpkm)) dataframes for each of the three datasets (Mouse, dev, wt) and for eac dataset by sex chromosome
rpkm.log  <- as.data.frame(rpkm(dgeMouse, normalized.lib.sizes = TRUE, log = TRUE))
rpkm_justX.log <- subset(rpkm.log, rownames(rpkm.log) %in% X_genes)
rpkm_justY.log <- subset(rpkm.log, rownames(rpkm.log) %in% Y_genes)
rpkm_allAuto.log <- subset(rpkm.log, rownames(rpkm.log) %in% Auto_genes)

#normalized reads of kilobase of transcript, per million mapped reads so that sum of squares is 1 (normalized rpkm) dataframes for each of the three datasets (Mouse, dev, wt) and for each dataset by sex chromosome
rpkm.norm  <- decostand(as.data.frame(rpkm(dgeMouse,  normalized.lib.sizes = TRUE)), "normalize")
rpkm_justX.norm <- subset(rpkm.norm, rownames(rpkm.norm) %in% X_genes)
rpkm_justY.norm <- subset(rpkm.norm, rownames(rpkm.norm) %in% Y_genes)
rpkm_allAuto.norm <- subset(rpkm.norm, rownames(rpkm.norm) %in% Auto_genes)
```

<h3>Set up CPM, rpkm, and Normalized FPKM data frames - subsetted by stage</h3>
```{r create-count-dfs-subsetted-by-stage}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each stage with both genotypes
subset_counts_by_stage <- function(stage) {
  #subset cpm/rpkm/rpkm.norm dataframes by stage of interest
  cpm_example <- cpm.log[,grep(stage, colnames(cpm.log))]
  rpkm_example <- rpkm.nonLog[,grep(stage, colnames(rpkm.nonLog))]
  rpkm.norm_example <- rpkm.norm[,grep(stage, colnames(rpkm.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", stage, sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", stage, sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", stage, sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", stage, sep = "_"),
               paste("rpkm", stage, sep = "_"),
               paste(paste("rpkm", stage, sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all stages
lapply(stages, subset_counts_by_stage)
```

<h3>Set up CPM, rpkm, and Normalized FPKM data frames - subsetted by cross</h3>
```{r create-count-dfs-subsetted-by-cross}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype with all crosses
subset_counts_by_genotype <- function(genotype) {
  #subset cpm/rpkm/rpkm.norm dataframes by genotype of interest
  cpm_example <- cpm.log[,grep(genotype, colnames(cpm.log))]
  rpkm_example <- rpkm.nonLog[,grep(genotype, colnames(rpkm.nonLog))]
  rpkm.norm_example <- rpkm.norm[,grep(genotype, colnames(rpkm.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, sep = "_"),
               paste("rpkm", genotype, sep = "_"),
               paste(paste("rpkm", genotype, sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes
lapply(genotypes, subset_counts_by_genotype)
```

<h3>Set up CPM, rpkm, and Normalized FPKM data frames - subsetted by genotype and stage but not by chromosome</h3>
```{r create-count-dfs-subsetted-by-cross-and-stage}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype and each cross
subset_counts_by_genotype_and_stage <- function(genotype, stage) {
  
  #subset cpm/rpkm/rpkm.norm dataframes by genotype and stage of interest
  cpm_example <- cpm.log[,grep(paste(genotype, stage, sep = ".*"), colnames(cpm.log))]
  rpkm_example <- rpkm.nonLog[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm.nonLog))]
  rpkm.norm_example <- rpkm.norm[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, stage, sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, stage, sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, stage, sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, stage, sep = "_"),
               paste("rpkm", genotype, stage, sep = "_"),
               paste(paste("rpkm", genotype, stage, sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes and stages
mapply(subset_counts_by_genotype_and_stage, expand.grid(genotypes, stages)$Var1, expand.grid(genotypes, stages)$Var2)
```

<h3>Create sex chromosomes subsets by genotype and genotype x stage</h3>
```{r create-count-dfs-justX-by-cross-and-stage}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype with all crosses - justX
subset_counts_by_genotype_justX <- function(genotype) {
  #subset cpm/rpkm/rpkm.norm dataframes by genotype of interest
  cpm_example <- cpm_justX.log[,grep(genotype, colnames(cpm_justX.log))]
  rpkm_example <- rpkm_justX.nonLog[,grep(genotype, colnames(rpkm_justX.nonLog))]
  rpkm.norm_example <- rpkm_justX.norm[,grep(genotype, colnames(rpkm_justX.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, "justX", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, "justX", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, "justX", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, "justX", sep = "_"),
               paste("rpkm", genotype, "justX", sep = "_"),
               paste(paste("rpkm", genotype, "justX", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes
lapply(genotypes, subset_counts_by_genotype_justX)


#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype and each cross
subset_counts_by_genotype_and_stage_justX <- function(genotype, stage) {
  
  #subset cpm/rpkm/rpkm.norm dataframes by genotype and stage of interest
  cpm_example <- cpm_justX.log[,grep(paste(genotype, stage, sep = ".*"), colnames(cpm_justX.log))]
  rpkm_example <- rpkm_justX.nonLog[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_justX.nonLog))]
  rpkm.norm_example <- rpkm_justX.norm[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_justX.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, stage, "justX", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, stage, "justX", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, stage, "justX", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, stage, "justX", sep = "_"),
               paste("rpkm", genotype, stage, "justX", sep = "_"),
               paste(paste("rpkm", genotype, stage, "justX", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes and stages
mapply(subset_counts_by_genotype_and_stage_justX, expand.grid(genotypes, stages)$Var1, expand.grid(genotypes, stages)$Var2)
```

```{r create-count-dfs-justY-by-cross-and-stage}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype with all crosses - justY
subset_counts_by_genotype_justY <- function(genotype) {
  #subset cpm/rpkm/rpkm.norm dataframes by genotype of interest
  cpm_example <- cpm_justY.log[,grep(genotype, colnames(cpm_justY.log))]
  rpkm_example <- rpkm_justY.nonLog[,grep(genotype, colnames(rpkm_justY.nonLog))]
  rpkm.norm_example <- rpkm_justY.norm[,grep(genotype, colnames(rpkm_justY.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, "justY", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, "justY", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, "justY", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, "justY", sep = "_"),
               paste("rpkm", genotype, "justY", sep = "_"),
               paste(paste("rpkm", genotype, "justY", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes
lapply(genotypes, subset_counts_by_genotype_justY)


#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype and each cross
subset_counts_by_genotype_and_stage_justY <- function(genotype, stage) {
  
  #subset cpm/rpkm/rpkm.norm dataframes by genotype and stage of interest
  cpm_example <- cpm_justY.log[,grep(paste(genotype, stage, sep = ".*"), colnames(cpm_justY.log))]
  rpkm_example <- rpkm_justY.nonLog[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_justY.nonLog))]
  rpkm.norm_example <- rpkm_justY.norm[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_justY.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, stage, "justY", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, stage, "justY", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, stage, "justY", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, stage, "justY", sep = "_"),
               paste("rpkm", genotype, stage, "justY", sep = "_"),
               paste(paste("rpkm", genotype, stage, "justY", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes and stages
mapply(subset_counts_by_genotype_and_stage_justY, expand.grid(genotypes, stages)$Var1, expand.grid(genotypes, stages)$Var2)
```


```{r create-count-dfs-allAuto-by-cross-and-stage}
#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype with all crosses - allAuto
subset_counts_by_genotype_allAuto <- function(genotype) {
  #subset cpm/rpkm/rpkm.norm dataframes by genotype of interest
  cpm_example <- cpm_allAuto.log[,grep(genotype, colnames(cpm_allAuto.log))]
  rpkm_example <- rpkm_allAuto.nonLog[,grep(genotype, colnames(rpkm_allAuto.nonLog))]
  rpkm.norm_example <- rpkm_allAuto.norm[,grep(genotype, colnames(rpkm_allAuto.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, "allAuto", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, "allAuto", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, "allAuto", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, "allAuto", sep = "_"),
               paste("rpkm", genotype, "allAuto", sep = "_"),
               paste(paste("rpkm", genotype, "allAuto", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes
lapply(genotypes, subset_counts_by_genotype_allAuto)


#create a function to subet cpm, rpkm, and rpkm.norm dataframes for each genotype and each cross
subset_counts_by_genotype_and_stage_allAuto <- function(genotype, stage) {
  
  #subset cpm/rpkm/rpkm.norm dataframes by genotype and stage of interest
  cpm_example <- cpm_allAuto.log[,grep(paste(genotype, stage, sep = ".*"), colnames(cpm_allAuto.log))]
  rpkm_example <- rpkm_allAuto.nonLog[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_allAuto.nonLog))]
  rpkm.norm_example <- rpkm_allAuto.norm[,grep(paste(genotype, stage, sep = ".*"), colnames(rpkm_allAuto.norm))]
  
  #assign subsets to new objects then print out the list of objects created
  assign(paste("cpm", genotype, stage, "allAuto", sep = "_"), cpm_example, envir = .GlobalEnv)
  assign(paste("rpkm", genotype, stage, "allAuto", sep = "_"), rpkm_example, envir = .GlobalEnv)
  assign(paste(paste("rpkm", genotype, stage, "allAuto", sep = "_"),"norm", sep = "."), rpkm.norm_example, envir = .GlobalEnv)
  
  return(paste("Created the following objects:", 
               paste("cpm", genotype, stage, "allAuto", sep = "_"),
               paste("rpkm", genotype, stage, "allAuto", sep = "_"),
               paste(paste("rpkm", genotype, stage, "allAuto", sep = "_"),"norm", sep = "."),
               sep = " "))
}

#apply function to all genotypes and stages
mapply(subset_counts_by_genotype_and_stage_allAuto, expand.grid(genotypes, stages)$Var1, expand.grid(genotypes, stages)$Var2)
```

<h3>Expression Levels for each Stage/Genotype</h3>
```{r rpkm-plot}
#create genotype x stage rpkm dataframes (with the different normalization methods)
cell_type_list <- c("MSHyb.*SP", "MSHyb.*LZ", "MSHyb.*DIP", "MSHyb.*RS", "MusP.*SP", "MusP.*LZ", "MusP.*DIP", "MusP.*RS", "DomP.*SP", "DomP.*LZ", "DomP.*DIP", "DomP.*RS")
cell_type_names <- c("MSHyb_SP", "MSHyb_LZ", "MSHyb_DIP", "MSHyb_RS", "MusP_SP", "MusP_LZ", "MusP_DIP", "MusP_RS", "DomP_SP", "DomP_LZ", "DomP_DIP", "DomP_RS")

#un-normalized rpkm
#set up empty dataframe
rpkm_by_cell_type <- data.frame(chr = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$chr, 
                                gene = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene,
                                X_category = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$X_category,
                                row.names = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene)

#define a function to get the average expression of each gene within a given cell type and append it to the rpkm_by_cell_type dataframe 
get_cell_type_mean_rpkm <- function(cell_type) {
  rpkm_by_cell_type <<- cbind(rpkm_by_cell_type, 
                              as.data.frame(rowMeans(rpkm.nonLog[,grep(cell_type, colnames(rpkm.nonLog))])))
}

#apply the get_cell_type_mean_rpkm across all cell types then rename colnames
invisible(lapply(cell_type_list, get_cell_type_mean_rpkm))
colnames(rpkm_by_cell_type) <- c("chr", "gene", "X_category", cell_type_names)
rpkm_by_cell_type_long <- data.frame(pivot_longer(rpkm_by_cell_type, 
                                                  cols = grep("^[M,D]", colnames(rpkm_by_cell_type)),
                                                  names_to = "cell_type",
                                                  values_to = "rpkm"))
rpkm_by_cell_type_long <- separate(rpkm_by_cell_type_long, 
                                   col = c("cell_type"), 
                                   into = c("genotype", "stage"), 
                                   remove = FALSE)
rpkm_by_cell_type_long$genotype <- factor(rpkm_by_cell_type_long$genotype,
                                          c("MusP", "MSHyb", "DomP"))
rpkm_by_cell_type_long$stage <- factor(rpkm_by_cell_type_long$stage,
                                       c("SP", "LZ", "DIP", "RS"))
rpkm_by_cell_type_long$X_category <- factor(rpkm_by_cell_type_long$X_category,
                                            c("Auto", "X", "Y"))




#log-normalized rpkm
#set up empty dataframe
rpkm_log_by_cell_type <- data.frame(chr = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$chr, 
                                    gene = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene,
                                    X_category = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$X_category,
                                    row.names = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene)

#define a function to get the average expression of each gene within a given cell type and append it to the rpkm_log_by_cell_type dataframe 
get_cell_type_mean_rpkm_log <- function(cell_type) {
  rpkm_log_by_cell_type <<- cbind(rpkm_log_by_cell_type, 
                                  as.data.frame(rowMeans(rpkm.log[,grep(cell_type, colnames(rpkm.log))])))
}

#apply the get_cell_type_mean_rpkm_log across all cell types then rename colnames
invisible(lapply(cell_type_list, get_cell_type_mean_rpkm_log))
colnames(rpkm_log_by_cell_type) <- c("chr", "gene", "X_category", cell_type_names)
rpkm_log_by_cell_type_long <- data.frame(pivot_longer(rpkm_log_by_cell_type, 
                                                      cols = grep("^[M,D]", colnames(rpkm_log_by_cell_type)),
                                                      names_to = "cell_type",
                                                      values_to = "rpkm"))
rpkm_log_by_cell_type_long <- separate(rpkm_log_by_cell_type_long, 
                                       col = c("cell_type"), 
                                       into = c("genotype", "stage"), 
                                       remove = FALSE)
rpkm_log_by_cell_type_long$genotype <- factor(rpkm_log_by_cell_type_long$genotype,
                                              c("MusP", "MSHyb", "DomP"))
rpkm_log_by_cell_type_long$stage <- factor(rpkm_log_by_cell_type_long$stage,
                                           c("SP", "LZ", "DIP", "RS"))
rpkm_log_by_cell_type_long$X_category <- factor(rpkm_log_by_cell_type_long$X_category,
                                                c("Auto", "X", "Y"))


#decostand normalized rpkm
#set up empty dataframe
rpkm_norm_by_cell_type <- data.frame(chr = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$chr, 
                                     gene = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene,
                                     X_category = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$X_category,
                                     row.names = annotations[annotations$gene %in% rownames(dgeMouse$genes),]$gene)

#define a function to get the average expression of each gene within a given cell type and append it to the rpkm_norm_by_cell_type dataframe 
get_cell_type_mean_rpkm_norm <- function(cell_type) {
  rpkm_norm_by_cell_type <<- cbind(rpkm_norm_by_cell_type, 
                                   as.data.frame(rowMeans(rpkm.norm[,grep(cell_type, colnames(rpkm.norm))])))
}

#apply the get_cell_type_mean_rpkm across all cell types then rename colnames
invisible(lapply(cell_type_list, get_cell_type_mean_rpkm_norm))
colnames(rpkm_norm_by_cell_type) <- c("chr", "gene", "X_category", cell_type_names)
rpkm_norm_by_cell_type_long <- data.frame(pivot_longer(rpkm_norm_by_cell_type, 
                                                       cols = grep("^[M,D]", colnames(rpkm_norm_by_cell_type)),
                                                       names_to = "cell_type",
                                                       values_to = "rpkm"))
rpkm_norm_by_cell_type_long <- separate(rpkm_norm_by_cell_type_long, 
                                        col = c("cell_type"), 
                                        into = c("genotype", "stage"), 
                                        remove = FALSE)
rpkm_norm_by_cell_type_long$genotype <- factor(rpkm_norm_by_cell_type_long$genotype,
                                               c("MusP", "MSHyb", "DomP"))
rpkm_norm_by_cell_type_long$stage <- factor(rpkm_norm_by_cell_type_long$stage,
                                            c("SP", "LZ", "DIP", "RS"))
rpkm_norm_by_cell_type_long$X_category <- factor(rpkm_norm_by_cell_type_long$X_category,
                                                 c("Auto", "X", "Y"))


rpkm_by_cell_type_density_plot <- ggplot(rpkm_by_cell_type_long, aes(x=rpkm, group = cell_type, color = stage, linetype = genotype)) +
  geom_density() + 
  theme_minimal() + 
  scale_color_manual(values = c(sp_color, lz_color, dip_color, rs_color)) +
  ylab("Mean Un-normalized FPKM across cell types") +
  theme(axis.title.x=element_blank(), 
        text = element_text(size = text_size*1.5), 
        plot.title = element_text(hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        axis.line.x.bottom = element_line(color = "black"),
        axis.line.y.left = element_line(color = "black")) 

rpkm_log_by_cell_type_density_plot <- ggplot(rpkm_log_by_cell_type_long, aes(x=rpkm, group = cell_type, color = stage, linetype = genotype)) +
  geom_density() + 
  theme_minimal() + 
  scale_color_manual(values = c(sp_color, lz_color, dip_color, rs_color)) +
  ylab("Mean Log-normalized FPKM across cell types") +
  theme(axis.title.x=element_blank(), 
        text = element_text(size = text_size*1.5), 
        plot.title = element_text(hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        axis.line.x.bottom = element_line(color = "black"),
        axis.line.y.left = element_line(color = "black")) 

rpkm_norm_by_cell_type_long_density_plot <- ggplot(rpkm_norm_by_cell_type_long, aes(x=rpkm, group = cell_type, color = stage, linetype = genotype)) +
  geom_density() + 
  theme_minimal() + 
  scale_color_manual(values = c(sp_color, lz_color, dip_color, rs_color)) +
  ylab("Mean Decostand-normalized FPKM across cell types") +
  theme(axis.title.x=element_blank(), 
        text = element_text(size = text_size*1.5), 
        plot.title = element_text(hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        axis.line.x.bottom = element_line(color = "black"),
        axis.line.y.left = element_line(color = "black")) 

rpkm_by_cell_type_density_plot
rpkm_log_by_cell_type_density_plot
rpkm_norm_by_cell_type_long_density_plot
```

<h3>Defining cell specific expressed genes (for use in hypergeometric tests of DE enrichment)</h3>
```{r defining-sets-of-expressed-genes}
#get expressed genes meeting filtering requirements from those DGEs you just set up
#expressed across all samples
all_exp <- rownames(dgeMouse$genes) #21212
#expressed across parents
MusP_DomP_all_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("P-", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) #20048

#expressed within M. m. musculus
MusP_all_exp <- rownames(dgeMusP$genes) #17581
#expressed within M. m. domesticus
DomP_all_exp <- rownames(dgeDomP$genes) #18167
#expressed within mus x dom hybrids
Hyb_all_exp <- rownames(dgeMSHyb$genes) #18512

#expressed within M. m. musculus for each stage
MusP_SP_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("MusP.*SP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12858
MusP_LZ_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("MusP.*LZ", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12105
MusP_DIP_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("MusP.*DIP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 11284
MusP_RS_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("MusP.*RS", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12672

#expressed within M. m. domesticus for each stage
DomP_SP_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("DomP.*SP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12878
DomP_LZ_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("DomP.*LZ", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12513
DomP_DIP_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("DomP.*DIP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 11332
DomP_RS_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("DomP.*RS", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12775

#expressed within hybrids and M. m. musculus for each stage
Hyb_MusP_SP_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("M.*SP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 14373
Hyb_MusP_LZ_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("M.*LZ", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 13700
Hyb_MusP_DIP_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("M.*DIP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12911
Hyb_MusP_RS_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("M.*RS", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 14720

#expressed within hybrids and M. m. domesticus for each stage
Hyb_DomP_SP_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,c(grep("MS.*SP",  colnames(rpkm.nonLog)), grep("DomP.*SP", colnames(rpkm.nonLog)))]  > rpkm.cutoff)  >= min.reps, ]) # 14694
Hyb_DomP_LZ_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,c(grep("MS.*LZ",  colnames(rpkm.nonLog)), grep("DomP.*LZ", colnames(rpkm.nonLog)))] > rpkm.cutoff)  >= min.reps, ]) # 13931
Hyb_DomP_DIP_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,c(grep("MS.*DIP", colnames(rpkm.nonLog)), grep("DomP.*DIP", colnames(rpkm.nonLog)))] > rpkm.cutoff)  >= min.reps, ]) # 13005
Hyb_DomP_RS_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,c(grep("MS.*RS",  colnames(rpkm.nonLog)), grep("DomP.*RS", colnames(rpkm.nonLog)))]  > rpkm.cutoff)  >= min.reps, ]) # 14787

#expressed within both parent species for each stage
MusP_DomP_SP_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("P.*SP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 14466
MusP_DomP_LZ_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("P.*LZ", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 13828
MusP_DomP_DIP_exp <- rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("P.*DIP", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 12864
MusP_DomP_RS_exp <-  rownames(rpkm.nonLog[rowSums(rpkm.nonLog[,grep("P.*RS", colnames(rpkm.nonLog))] > rpkm.cutoff)  >= min.reps, ]) # 14792

#make lists of cell types for hypergeometric tests
Hyb_MusP_cell_exp.list <- c("Hyb_MusP_SP_exp", "Hyb_MusP_LZ_exp", "Hyb_MusP_DIP_exp", "Hyb_MusP_RS_exp")
Hyb_DomP_cell_exp.list <- c("Hyb_DomP_SP_exp", "Hyb_DomP_LZ_exp", "Hyb_DomP_DIP_exp", "Hyb_DomP_RS_exp")
par_cell_exp.list <- c("MusP_DomP_SP_exp", "MusP_DomP_LZ_exp", "MusP_DomP_DIP_exp", "MusP_DomP_RS_exp")
```

<h3>Define sets of induced genes for each stage</h3>
```{r defining-induced}
#define sets of genes "induced" in each cell type; these are genes with a median expression in a given stage that is 2 (induced_cutoff) times higher than the median expression in all other cell types
induced_cutoff <- 2

define_induced <- function(stage) {
  focal_stages <- grep(stage, cell_type_names, value = TRUE)
  nonFocal_stages <- grep(stage, cell_type_names, value = TRUE, invert = TRUE)
  expressed_genes <- get(paste("MusP_DomP_", stage, "_exp", sep = ""))
  
  #finds genes expressed in both parents in a given stage and those that meet the expression cutoff
  example_induced <- rownames(rpkm_by_cell_type[rownames(rpkm_by_cell_type) %in% expressed_genes
                                                & rowMedians(as.matrix(rpkm_by_cell_type[,focal_stages])) >
                                                  rowMedians(as.matrix(rpkm_by_cell_type[,nonFocal_stages]))*induced_cutoff, ])
  example_Auto_induced <- example_induced[!(example_induced %in% Auto_genes)]
  example_X_induced <- example_induced[(example_induced %in% X_genes)]
  
  
  assign(paste(stage, "induced", sep = "_"), example_induced, envir = .GlobalEnv)
  assign(paste(stage, "Auto_induced", sep = "_"), example_Auto_induced, envir = .GlobalEnv)
  assign(paste(stage, "X_induced", sep = "_"), example_X_induced, envir = .GlobalEnv)
  
  write.table(example_induced, 
              file = paste("induced/mouse_", stage ,"_induced_cutoff_", induced_cutoff,".txt", sep = ""), 
              sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
  write.table(example_Auto_induced, 
              file = paste("induced/mouse_", stage ,"_induced_X_cutoff_", induced_cutoff,".txt", sep = ""), 
              sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
  write.table(example_X_induced, 
              file = paste("induced/mouse_", stage ,"_induced_Auto_cutoff_", induced_cutoff,".txt", sep = ""), 
              sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}

invisible(lapply(stages, define_induced))
```

<h3>Compare sets of overexpressed genes during diplotene</h3>
```{r diplotene-escapee-genes}
#establishes comparable sets of orthologous induced genes
#threshold for determining parental and hybrid escapee genes; selecting for top 10% of genes then determining what rpkm threshold corresponds to that
threshold <- 0.90
mouse_parental_threshold <- quantile(rowMeans(rpkm_MusP_DIP_justX.norm), probs = c(threshold))

#define two sets of genes:
#parental_escapees; the top 10% of genes expressed in parental diplotene (MSCI escapees)
mouse_parental_escapees <- names(rowMeans(rpkm_MusP_DIP_justX.norm)[rowMeans(rpkm_MusP_DIP_justX.norm) >
                                                                      mouse_parental_threshold])

#hybrid_escapees; the top 10% of genes expressed in hybrid diplotene (overexpressed X-linked genes)
mouse_hybrid_escapees <- names(rowMeans(rpkm_MSHyb_DIP_justX.norm)[rowMeans(rpkm_MSHyb_DIP_justX.norm) > mouse_parental_threshold])


#write escapees out to file for comparison to dwarf hamster escapees
write.table(mouse_parental_escapees, file = paste("induced/mouse_parental_escapees_inducedCutoff_", induced_cutoff,".txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(mouse_hybrid_escapees, file = paste("induced/mouse_hybrid_escapees_inducedCutoff_", induced_cutoff,".txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```

<h3>MDS Plots of each dataset and stage</h3>
```{r mds-plots-multi-pane-figure-by-stage}
#set MDS plotting parameters
c_value <- 2
l_value <- 1
#number of genes to use in MDS analysis
t_value <- 500

#set colors
dev_stage_colors <- color_list[metadata$stage[metadata$stage != "WT"]]

#function that adjusts MDS plot labels to be more readable
mds_labels <- function(dge_of_interest) {
  label_vector <- colnames(dge_of_interest$counts)
  label_vector <- gsub("-.*","",label_vector)
  label_vector <- gsub("MusP","Mus",label_vector)
  label_vector <- gsub("DomP","Dom",label_vector)
  label_vector <- gsub("MSHyb","sterile",label_vector)
  return(label_vector)
}

#grid of MDS plots of SP, LZ, DIP, and RS samples
if (exportFigs == TRUE) {
  pdf(file = paste("exported_figures/MDS_plots_mouse_by_stage_outlines_cex", c_value, "_top", t_value, ".pdf", sep = ""), width = 6.5, height = 5, pointsize = 12)
}
layout(matrix(c(1,2,3,4), ncol = 2, byrow = TRUE))

#SP MDS
par(mar=c(3, 3, 2, 1), mgp=c(1.5, 0.5, 0))
metadata$stage <- factor(metadata$stage, levels = stages)
stage_colors <- color_list[metadata$stage]
plotMDS(dgeSP, top = t_value, lwd = l_value, col = color_list["SP"], pch = as.numeric(gsub("sterile", 4, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeSP))))), cex = c_value, main = "Mitosis (SP)", plot = TRUE, cex.lab = 0.75, cex.main = 1, cex.axis = 0.75)

#LZ MDS
plotMDS(dgeLZ, top = t_value, lwd = l_value, col = color_list["LZ"], pch = as.numeric(gsub("sterile", 4, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeLZ))))), cex = c_value, main = "Meiosis-Before X-Inact. (LZ)", plot = TRUE, cex.lab = 0.75, cex.main = 1, cex.axis = 0.75)

#DIP MDS
plotMDS(dgeDIP, top = t_value, lwd = l_value, col = color_list["DIP"], pch = as.numeric(gsub("sterile", 4, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeDIP))))), cex = c_value, main = "Meiosis-After X-Inact. (DIP)", plot = TRUE, cex.lab = 0.75, cex.main = 1, cex.axis = 0.75)

#RS MDS
plotMDS(dgeRS, top = t_value, lwd = l_value, col = color_list["RS"], pch = as.numeric(gsub("sterile", 4, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeRS))))), cex = c_value, main = "Postmeiosis (RS)", plot = TRUE, cex.lab = 0.75, cex.main = 1, cex.axis = 0.75)

if (exportFigs == TRUE) {
  dev.off()
}
```

<h3>X Chromosome MDSPlots</h3>
```{r mds-plots-of-X-and-Auto}
#MDS plot of X-linked expression for all samples
#set MDS plotting parameters
c_value <- 2
l_value <- 1
#number of genes to use in MDS analysis
t_value <- 500

#make grid of X-linked and Autosomal gene MDS plots for house mouse
#X-linked
if(exportFigs == TRUE) {
  pdf(file = "exported_figures/MDS_X-linked_dev_samples_colored_by_genotype_with_symbols_mouse.pdf", width=5, height=4, pointsize=12)
}

plotMDS(dgeX, top = t_value, lwd =2, col=dev_stage_colors, pch = as.numeric(gsub("sterile", 4, gsub("fertile", 1, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeX)))))), cex = c_value, plot = TRUE)
title("X MDS - mouse")

if(exportFigs == TRUE) {
  dev.off()
}

#Auto
if(exportFigs == TRUE) {
  pdf(file = "exported_figures/MDS_Autosomal_dev_samples_colored_by_genotype_with_symbols_mouse.pdf", width=5, height=4, pointsize=12)
}
plotMDS(dgeAuto, top = t_value, lwd =2, col=dev_stage_colors, pch = as.numeric(gsub("sterile", 4, gsub("fertile", 1, gsub("Mus", 2, gsub("Dom", 6, mds_labels(dgeX)))))), cex = c_value, plot = TRUE)
title("Autosomal MDS - mouse")

if(exportFigs == TRUE) {
  dev.off()
}
```

```{r create-orthology-countfiles}
#make and normalize a DGEList of just Mmus genes that have Psun orthology
orthology_df <- read.csv("input_data//mouse_hamster_orthology_29May23.csv")

#MDS analysis of mus samples based only off of orthologous genes with hamster
dgeMus_orthology <- DGEList(counts=just_counts[rownames(just_counts) %in% orthology_df$mGene,
                                               grep("WT", colnames(just_counts), value = FALSE, invert = TRUE)], 
                            genes=annotations[rownames(annotations) %in% orthology_df$mGene,], 
                            group=grep("WT", colnames(just_counts), value = TRUE, invert = TRUE)) 
dgeMus_orthology <- calcNormFactors(dgeMus_orthology)
plotMDS(dgeMus_orthology)

#cpm normalized and log transformed expression dataset
mus_orthology.cpm <- cpm(dgeMus_orthology, log=TRUE, prior.count=1, normalized.lib.sizes=TRUE) 
mus_orthology.rpkm <- as.data.frame(rpkm(dgeMus_orthology,  normalized.lib.sizes = TRUE, log = TRUE))

write.csv(mus_orthology.cpm, file = "exported_files/mus_orthology_cpm_norm_counts.csv")
write.csv(mus_orthology.rpkm, file = "exported_files/mus_orthology_rpkm_norm_counts.csv")
```

<h3>Heatmaps of Log(Normalized(RPKM)) for the autosomes and X chromosome from all data</h3>
```{r heatmaps-of-x-genes}
#heatmap of normalized rpkm values for x-linked genes from all stages; un-normalized rpkm is not useful for visualizing differences
#choose colors
colfunc <- colorRampPalette(c("#FFFFFF", "#2F2323"))
gap_value <- 4
total_number <- 255 + (15*gap_value)
browns_mod <- colfunc(total_number)
browns_mod <- browns_mod[c(seq(1,1+(15*gap_value),gap_value),seq(2+(15*gap_value),total_number,1))]

#auto heatmap; uncomment if desired
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Heatmap_mouse_allAuto_all-genotypes_all_stages.pdf", width=10, height=8, pointsize=12)
}
Heatmap(as.matrix(rpkm_allAuto.norm), name = "Autosomal expression (rpkm)", column_order = Full_heatmap_order, column_names_gp = gpar(fontsize=4), show_row_names = FALSE, col = browns_mod, show_row_dend = FALSE, cluster_columns = FALSE, use_raster = FALSE)
if(exportFigs == TRUE) {
  dev.off()
}

#x-linked heatmap with genes ordered by clustering
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Heatmap_mouse_justX_all-genotypes_all_stages.pdf", width=10, height=8, pointsize=12)
}
Heatmap(as.matrix(rpkm_justX.norm), name = "X-linked expression (rpkm)", column_order = Full_heatmap_order, column_names_gp = gpar(fontsize=4), show_row_names = FALSE, col = browns_mod, show_row_dend = FALSE, cluster_columns = FALSE)
if(exportFigs == TRUE) {
  dev.off()
}
```

<h3>Determine which parental stages hybrid diplotene samples are most similar to</h3>
```{r which-stage-does-hybDIP-correlate-to}
#the goal of this section is to see which parental stages the hybrid diplotene samples have the highest expression correlations to; then to see how those parental stage correlations differ between house mice and dwarf hamsters

#calculate rho of X-linked correlations
hyb_v_MusP_SP_X_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_justX.norm), rowMeans(rpkm_MusP_SP_justX.norm))
hyb_v_MusP_LZ_X_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_justX.norm), rowMeans(rpkm_MusP_LZ_justX.norm))
hyb_v_MusP_DIP_X_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_justX.norm), rowMeans(rpkm_MusP_DIP_justX.norm))
hyb_v_MusP_RS_X_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_justX.norm), rowMeans(rpkm_MusP_RS_justX.norm))

#calculate rho of autosomal correlations
hyb_v_MusP_SP_Auto_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_allAuto.norm), rowMeans(rpkm_MusP_SP_allAuto.norm))
hyb_v_MusP_LZ_Auto_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_allAuto.norm), rowMeans(rpkm_MusP_LZ_allAuto.norm))
hyb_v_MusP_DIP_Auto_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_allAuto.norm), rowMeans(rpkm_MusP_DIP_allAuto.norm))
hyb_v_MusP_RS_Auto_corr <- cor.test(rowMeans(rpkm_MSHyb_DIP_allAuto.norm), rowMeans(rpkm_MusP_RS_allAuto.norm))

#begin bootstrap analysis of correlation coefficient
reps <- 1000

bootstrap_correlation_analysis <- function(comparison) {
  example_stage <- unlist(strsplit(comparison, split = "_"))[1]
  example_X_cat <- unlist(strsplit(comparison, split = "_"))[2]
  
  example_X_cat_genes <- get(paste("filtered_", example_X_cat,"_genes", sep = ""))
  
  hybrid_rpkm_rowMeans <- rowMeans(get(paste("rpkm_MSHyb_DIP_", example_X_cat, ".norm", sep = "")))
  parent_rpkm_rowMeans <- rowMeans(get(paste("rpkm_MusP_", example_stage, "_", example_X_cat, ".norm", sep = "")))
  
  combined_rpkm_df <- data.frame(hyb = hybrid_rpkm_rowMeans, par = parent_rpkm_rowMeans)
  
  sample_combined_rpkm_df <- function(example_rpkm_df) {
    sampled_combined_rpkm_df <- example_rpkm_df[sample(rownames(example_rpkm_df), 
                                                       length(rownames(example_rpkm_df)), replace = TRUE),]
    
    sampled_corr_test_estimate <- cor.test(sampled_combined_rpkm_df$hyb, 
                                           sampled_combined_rpkm_df$par, 
                                           method = "pearson")$estimate
    return(sampled_corr_test_estimate)
  }
  
  sampled_corr_test_estimates <- replicate(reps, sample_combined_rpkm_df(combined_rpkm_df))
  
  return(data.frame(stage = example_stage, X_cat = example_X_cat, corr = sampled_corr_test_estimates))
}

bootstap_correlations_list <- lapply(c("SP_justX", "LZ_justX", "DIP_justX", "RS_justX",
                                       "SP_allAuto", "LZ_allAuto", "DIP_allAuto", "RS_allAuto"), 
                                     bootstrap_correlation_analysis)

bootstap_correlations_df <- do.call(rbind, bootstap_correlations_list)

colnames(bootstap_correlations_df) <- c("stage", "X_cat" ,"rho")
bootstap_correlations_df$stage <- factor(bootstap_correlations_df$stage, levels = c("SP", "LZ", "DIP", "RS"))
bootstap_correlations_df$X_cat <- factor(bootstap_correlations_df$X_cat, levels = c("justX", "allAuto"))


bootstrap_calculate_CI <- function(comparison) {
  example_stage <- unlist(strsplit(comparison, split = "_"))[1]
  example_X_cat <- unlist(strsplit(comparison, split = "_"))[2]
  
  exaxmple_ci <- round(quantile(bootstap_correlations_df[bootstap_correlations_df$stage == example_stage & 
                                                           bootstap_correlations_df$X_cat == example_X_cat,]$rho, 
                                probs = c(0.025, 0.975)), 4)
  return(c(example_stage, example_X_cat, exaxmple_ci))
}

bootstap_confidence_intervals_df <- data.frame(do.call(rbind, lapply(c("SP_justX", "LZ_justX", "DIP_justX", "RS_justX",
                                                                       "SP_allAuto", "LZ_allAuto", "DIP_allAuto", "RS_allAuto"),
                                                                     bootstrap_calculate_CI)))

colnames(bootstap_confidence_intervals_df) <- c("stage", "X_cat", "CI_lower", "CI_upper")


#collate all correlation data then fdr correct actual (non-bootstrap) X-linked correlation rhos
hybDIP_corr_table_mouse <- data.frame(stage = bootstap_confidence_intervals_df[1],
                                      
                                      pVals = c(hyb_v_MusP_SP_X_corr$p.value, 
                                                hyb_v_MusP_LZ_X_corr$p.value, 
                                                hyb_v_MusP_DIP_X_corr$p.value, 
                                                hyb_v_MusP_RS_X_corr$p.value,
                                                hyb_v_MusP_SP_Auto_corr$p.value, 
                                                hyb_v_MusP_LZ_Auto_corr$p.value, 
                                                hyb_v_MusP_DIP_Auto_corr$p.value, 
                                                hyb_v_MusP_RS_Auto_corr$p.value),
                                      
                                      corVals = c(hyb_v_MusP_SP_X_corr$estimate,
                                                  hyb_v_MusP_LZ_X_corr$estimate,
                                                  hyb_v_MusP_DIP_X_corr$estimate,
                                                  hyb_v_MusP_RS_X_corr$estimate,
                                                  hyb_v_MusP_SP_Auto_corr$estimate,
                                                  hyb_v_MusP_LZ_Auto_corr$estimate,
                                                  hyb_v_MusP_DIP_Auto_corr$estimate,
                                                  hyb_v_MusP_RS_Auto_corr$estimate),
                                      
                                      comp = c("Mouse-X",
                                               "Mouse-X",
                                               "Mouse-X",
                                               "Mouse-X",
                                               "Mouse-Auto",
                                               "Mouse-Auto",
                                               "Mouse-Auto",
                                               "Mouse-Auto"),
                                      
                                      species = c("Mouse",
                                                  "Mouse",
                                                  "Mouse",
                                                  "Mouse",
                                                  "Mouse",
                                                  "Mouse",
                                                  "Mouse",
                                                  "Mouse"),
                                      
                                      CI_lower = as.numeric(unlist(bootstap_confidence_intervals_df[3])),
                                      
                                      CI_upper = as.numeric(unlist(bootstap_confidence_intervals_df[4])))

#formatting data frame
hybDIP_corr_table_mouse$stage   <- factor(hybDIP_corr_table_mouse$stage, levels = c("SP", "LZ", "DIP", "RS"))
hybDIP_corr_table_mouse$comp    <- factor(hybDIP_corr_table_mouse$comp, levels = c("Mouse-Auto", "Mouse-X"))
hybDIP_corr_table_mouse$comb_comp <- paste(hybDIP_corr_table_mouse$comp, hybDIP_corr_table_mouse$stage, sep = "-")
hybDIP_corr_table_mouse$comb_comp    <- factor(hybDIP_corr_table_mouse$comb_comp, levels = c("Mouse-Auto-SP", "Mouse-X-SP",
                                                                                             "Mouse-Auto-LZ", "Mouse-X-LZ",
                                                                                             "Mouse-Auto-DIP", "Mouse-X-DIP",
                                                                                             "Mouse-Auto-RS", "Mouse-X-RS"))
hybDIP_corr_table_mouse$species <- factor(hybDIP_corr_table_mouse$species, levels = c("Mouse"))
#the FDR correction
hybDIP_corr_table_mouse$pAdj    <- p.adjust(hybDIP_corr_table_mouse$pVals, method = "fdr")

#add column indicating if correlation is significant for use in plot coloring
hybDIP_corr_table_mouse$sig <- ""
if(sum(hybDIP_corr_table_mouse$pAdj < 0.05) > 0){
  hybDIP_corr_table_mouse[hybDIP_corr_table_mouse$pAdj < 0.05,]$sig <- "yes"
}
if(sum(hybDIP_corr_table_mouse$pAdj > 0.05) > 0){
  hybDIP_corr_table_mouse[hybDIP_corr_table_mouse$pAdj > 0.05,]$sig <- "no"
}

#print summary of mouse X-linked rho stats
print(paste("hybDIP_MusP_SP_X rho X: ", round(hybDIP_corr_table_mouse$corVals[1], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[1], 4), 
            sep = ""))
print(paste("hybDIP_MusP_LZ_X rho X: ", round(hybDIP_corr_table_mouse$corVals[2], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[2], 3), 
            sep = ""))
print(paste("hybDIP_MusP_RS_X rho X: ", round(hybDIP_corr_table_mouse$corVals[4], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[4], 3), 
            sep = ""))

#print summary of mouse autosomal rho stats
print(paste("hybDIP_MusP_SP_Auto rho Auto: ", round(hybDIP_corr_table_mouse$corVals[5], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[5], 3), 
            sep = ""))
print(paste("hybDIP_MusP_LZ_Auto rho Auto: ", round(hybDIP_corr_table_mouse$corVals[6], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[6], 3), 
            sep = ""))
print(paste("hybDIP_MusP_RS_Auto rho Auto: ", round(hybDIP_corr_table_mouse$corVals[8], 4), "; p = ",
            round(hybDIP_corr_table_mouse$pAdj[8], 3), 
            sep = ""))

#export data for use in comparisons with dwarf hamsters
write.csv(hybDIP_corr_table_mouse, file = "exported_files/hybDIP_correlation_mouse.csv")
```

<h1>Differential Expression</h1>
<h3>Design set-up</h3>
```{r de-design-matrix}
#set up differential expression experimental design and contrasts
design <- cbind(rownames(metadata),
                metadata[c("cross", "stage", "condition_name")])
design$condition_name <- factor(design$condition_name)
colnames(design) <- c("sample_ID", "cross", "stage", "condition_name")
design$condition_name <- gsub("-",".",design$condition_name)
design$condition_name <- as.factor(design$condition_name)

#create DE contrast matrix
designMatrix  <-  model.matrix(~0+design$condition_name)
colnames(designMatrix)  <-  levels(design$condition_name)
rownames(designMatrix)  <-  design$sample_ID
```

<h3>Defining contrasts</h3>
```{r de-defining contrasts}
#set up DE contrasts
contrast.list <- makeContrasts(
  # compare cell types between hybrids and musculus
  Hyb.MusP.SP  =  MSHyb.SP - MusP.SP,  
  Hyb.MusP.LZ  =  MSHyb.LZ - MusP.LZ, 
  Hyb.MusP.DIP  =  MSHyb.DIP - MusP.DIP,
  Hyb.MusP.RS  =  MSHyb.RS - MusP.RS,
  
  # compare cell types between hybrids and domesticus
  Hyb.DomP.SP   =  MSHyb.SP -  DomP.SP,  
  Hyb.DomP.LZ   =  MSHyb.LZ -  DomP.LZ, 
  Hyb.DomP.DIP  =  MSHyb.DIP - DomP.DIP,
  Hyb.DomP.RS  =  MSHyb.DIP - DomP.RS,
  
  # parents
  MusP.DomP.SP  =   MusP.SP -  DomP.SP, 
  MusP.DomP.LZ  =   MusP.LZ -  DomP.LZ, 
  MusP.DomP.DIP  =  MusP.DIP - DomP.DIP, 
  MusP.DomP.RS  =   MusP.RS  - DomP.RS, 
  
  levels  =  designMatrix
)
contrast.list
```

<h3>Dispersion estimates of main datasets</h3>
```{r bcv-calculations}
#calculate BCV (biological coefficient of variation) for main DE analysis; this is a calculation of the intra-replicate variability
dgeMouse <- estimateGLMCommonDisp(dgeMouse, designMatrix, verbose = TRUE)  
dgeMouse <- estimateGLMTrendedDisp(dgeMouse, designMatrix) 
dgeMouse <- estimateGLMTagwiseDisp(dgeMouse, designMatrix) 

#generate BCV plots
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Dispersion_plots_mouse_dataset.pdf", width=10, height=8, pointsize=12)
  plotBCV(dgeMouse, main = paste("Dev dataset (all genes); BCV = ",round(sqrt(dgeMouse$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
  dev.off()
} else {
  plotBCV(dgeMouse, main = paste("Dispersion estimates for Dev dataset; BCV = ",round(sqrt(dgeMouse$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
}
```

<h3>Fit model and calculate DE genes</h3>
```{r calculate-DE-genes}
#set the false discovery rate
FDR_cutoff <- 0.05
logFC_cutoff <- 1.25

contrasts_Mouse <- colnames(contrast.list)

retrieve_contrast_DEs <- function(example_contrast) {
  #perform LRT
  example_lrt <- glmLRT(glmFit(dgeMouse,  designMatrix), 
                        contrast = contrast.list[,example_contrast])
  assign(paste(example_contrast, "LRT", sep = "_"), example_lrt, envir = .GlobalEnv)
  
  #extract DE genes
  example_tt <- topTags(example_lrt, n = nrow(example_lrt))
  example_de <- example_tt$table[example_tt$table$FDR <= FDR_cutoff &
                                   abs(example_tt$table$logFC) >= logFC_cutoff, ]
  
  setorder(example_tt$table, -logFC)
  
  assign(paste(example_contrast, "tt", sep = "."), example_tt, envir = .GlobalEnv)
  assign(paste(example_contrast, "de", sep = "."), example_de, envir = .GlobalEnv)
  
  return(data.frame(non_DE = sum(example_tt$table$FDR > 0.05),
                    stage_up_DE = sum(example_tt$table$FDR <= 0.05 & abs(example_tt$table$logFC) < logFC_cutoff),
                    stage_down_DE = sum(example_tt$table$FDR <= 0.05 & abs(example_tt$table$logFC) > logFC_cutoff)))
}

#calculate DE genes for each stages
sapply(contrasts_Mouse, retrieve_contrast_DEs)

#create a dataframe of genes that are DE between hybrids and BOTH parents
Hyb.Comb.SP.de <- merge(Hyb.MusP.SP.de, Hyb.DomP.SP.de, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"),
                        all = TRUE)
Hyb.Comb.LZ.de <- merge(Hyb.MusP.LZ.de, Hyb.DomP.LZ.de, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))
Hyb.Comb.DIP.de <- merge(Hyb.MusP.DIP.de, Hyb.DomP.DIP.de, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))
Hyb.Comb.RS.de <- merge(Hyb.MusP.RS.de, Hyb.DomP.RS.de, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))

#create a dataframe of all genes with logFC info for both parents
Hyb.Comb.SP.tt <- merge(Hyb.MusP.SP.tt$table, Hyb.DomP.SP.tt$table, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))
Hyb.Comb.LZ.tt <- merge(Hyb.MusP.LZ.tt$table, Hyb.DomP.LZ.tt$table, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))
Hyb.Comb.DIP.tt <- merge(Hyb.MusP.DIP.tt$table, Hyb.DomP.DIP.tt$table, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))
Hyb.Comb.RS.tt <- merge(Hyb.MusP.RS.tt$table, Hyb.DomP.RS.tt$table, by = c("Length", "chr", "start", "stop", "gene", "X_category", "gene_name"))

Hyb.Comb.SP.tt$stage <- "SP"
Hyb.Comb.LZ.tt$stage <- "LZ"
Hyb.Comb.DIP.tt$stage <- "DIP"
Hyb.Comb.RS.tt$stage <- "RS"

Hyb.Comb.SP.tt$species <- "mouse"
Hyb.Comb.LZ.tt$species <- "mouse"
Hyb.Comb.DIP.tt$species <- "mouse"
Hyb.Comb.RS.tt$species <- "mouse"

#write out parent DE gene files to supplement; the hybrid DE genes are written out in a chunk below after the DE categories have been defined
write.csv(MusP.DomP.SP.de,  paste("exported_files/parent_mouse_SP_DE_Genes_logFC_", logFC_cutoff, ".csv", sep = ""))
write.csv(MusP.DomP.LZ.de,  paste("exported_files/parent_mouse_LZ_DE_Genes_logFC_", logFC_cutoff, ".csv", sep = ""))
write.csv(MusP.DomP.DIP.de, paste("exported_files/parent_mouse_DIP_DE_Genes_logFC_", logFC_cutoff, ".csv", sep = ""))
write.csv(MusP.DomP.RS.de,  paste("exported_files/parent_mouse_RS_DE_Genes_logFC_", logFC_cutoff, ".csv", sep = ""))
```
```{r eligible-DE-expressed genes}
#define background sets of genes for tests of overlap between mouse and hamster based on if gene had a calculatable logFC in DE contrasts for a given stage 
Hyb_Comb_SP_exp <- Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$logFC.x != 0 & Hyb.Comb.SP.tt$logFC.y != 0,]$gene # 20697
Hyb_Comb_LZ_exp <- Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$logFC.x != 0 & Hyb.Comb.LZ.tt$logFC.y != 0,]$gene # 20414
Hyb_Comb_DIP_exp <- Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$logFC.x != 0 & Hyb.Comb.DIP.tt$logFC.y != 0,]$gene # 20350
Hyb_Comb_RS_exp <- Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$logFC.x != 0 & Hyb.Comb.RS.tt$logFC.y != 0,]$gene # 20153

#export the genes expressed across all three crosses in each stage
write.csv(annotations[annotations$gene %in% Hyb_Comb_SP_exp,c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_SP_all_exp_genes.csv")
write.csv(annotations[annotations$gene %in% Hyb_Comb_LZ_exp,c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_LZ_all_exp_genes.csv")
write.csv(annotations[annotations$gene %in% Hyb_Comb_DIP_exp,c("gene", "gene_name")], row.names = FALSE,
          "exported_files/Mouse_DIP_all_exp_genes.csv")
write.csv(annotations[annotations$gene %in% Hyb_Comb_RS_exp,c("gene", "gene_name")], row.names = FALSE,
          "exported_files/Mouse_RS_all_exp_genes.csv")

#export the genes expressed across all three crosses in each stage on the X chromosome
write.csv(annotations[annotations$gene %in% Hyb_Comb_SP_exp &
                        annotations$X_category == "X",
                      c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_SP_X_exp_genes.csv") #811
write.csv(annotations[annotations$gene %in% Hyb_Comb_LZ_exp &
                        annotations$X_category == "X",
                      c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_LZ_X_exp_genes.csv") #784
write.csv(annotations[annotations$gene %in% Hyb_Comb_DIP_exp &
                        annotations$X_category == "X",
                      c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_DIP_X_exp_genes.csv") #760
write.csv(annotations[annotations$gene %in% Hyb_Comb_RS_exp &
                        annotations$X_category == "X",
                      c("gene", "gene_name")],  row.names = FALSE,
          "exported_files/Mouse_RS_X_exp_genes.csv") #747

Hyb_Comb_cell_exp_list <- c("Hyb_Comb_SP_exp", "Hyb_Comb_LZ_exp", "Hyb_Comb_DIP_exp", "Hyb_Comb_RS_exp")
```

```{r transgressive-expression}
define_transressive_expression_and_plot <- function (example_stage) {
  #get relavant data frame for stage
  example_tt <- get(paste("Hyb.Comb.", example_stage, ".tt", sep = ""))
  
  #add column indicating whether genes in hybrids were DE relative to both parents
  example_tt$sig_in_both <- "no"
  example_tt[example_tt$FDR.x < 0.05 & 
               example_tt$FDR.y < 0.05 &
               abs(example_tt$logFC.x) > logFC_cutoff & 
               abs(example_tt$logFC.y) > logFC_cutoff,]$sig_in_both <- "yes" 
  
  #add column indicating whether genes in hybrids were DE relative to only MusP
  example_tt$sig_in_sameX <- "no"
  example_tt[example_tt$FDR.x < 0.05 &
               abs(example_tt$logFC.x) > logFC_cutoff,]$sig_in_sameX <- "yes" 
  
  #add column indicating whether genes in hybrids were DE relative to only DomP
  example_tt$sig_in_diffX <- "no"
  example_tt[example_tt$FDR.y < 0.05 &
               abs(example_tt$logFC.y) > logFC_cutoff,]$sig_in_diffX <- "yes" 
  
  #classify genes as not_different, sameX_only, diffX_only, intermediate, or transgressive
  
  #by default, genes are classified as not different from parentals if not DE in both directions
  example_tt$category <- "not_different"
  
  #genes are classified as intermediate if DE in both directions, and less than one parent and greater than the other; this is wrong
  example_tt[example_tt$sig_in_diffX == "yes" &
               example_tt$sig_in_sameX == "no",]$category <- "diffX_only"
  
  example_tt[example_tt$sig_in_sameX == "yes" &
               example_tt$sig_in_diffX == "no",]$category <- "sameX_only"
  
  
  #genes are classified as transgressive if DE in both directions, and either greater than both parents, or less than both parents
  example_tt[example_tt$sig_in_both == "yes" &
               example_tt$logFC.x > logFC_cutoff &
               example_tt$logFC.y > logFC_cutoff,]$category <- "transgressive"
  
  example_tt[example_tt$sig_in_both == "yes" &
               example_tt$logFC.x < -logFC_cutoff &
               example_tt$logFC.y < -logFC_cutoff,]$category <- "transgressive"
  
  
  #genes are classified as intermediate if DE in both directions, and less than one parent and greater than the other; this is wrong
  example_tt[example_tt$sig_in_both == "yes" &
               example_tt$logFC.x > logFC_cutoff &
               example_tt$logFC.y < -logFC_cutoff,]$category <- "intermediate"
  
  example_tt[example_tt$sig_in_both == "yes" &
               example_tt$logFC.x < -logFC_cutoff &
               example_tt$logFC.y > logFC_cutoff,]$category <- "intermediate"
  
  example_tt$category <- factor(example_tt$category, levels = c("transgressive",
                                                                "intermediate", 
                                                                "sameX_only", 
                                                                "diffX_only",
                                                                "not_different"))
  
  setorder(example_tt, -category)
  
  
  
  example_category_plot <- ggplot(data = example_tt, aes(x = logFC.x, y = logFC.y, color = category)) +
    geom_hline(yintercept = 0, linewidth = 0.5) +
    geom_vline(xintercept = 0, linewidth = 0.5) +
    geom_point(alpha = 0.7, size = 0.4) +
    scale_color_manual(values = unname(c(color_list_darkest[example_stage], 
                                         color_list[example_stage], 
                                         gray_5, 
                                         gray_4, 
                                         gray_2))) +
    theme_bw() +
    xlab("log2FC(mus x dom hybrid) - log2FC(mus)") +
    ylab("log2FC(mus x dom hybrid) - log2FC(dom)") +
    theme(legend.position = "none",
          text = element_text(size = 4)) +
    ylim(-12.5, 12.5) +
    xlim(-12.5, 12.5)
  
  assign(paste(example_stage, "_DE_category_plot", sep = ""), example_category_plot, envir = .GlobalEnv)
  assign(paste("Hyb.Comb.", example_stage, ".tt", sep = ""), example_tt, envir = .GlobalEnv)
}

invisible(lapply(stages, define_transressive_expression_and_plot))

all_stages_DE_category_plot <- plot_grid(SP_DE_category_plot,
                                         LZ_DE_category_plot,
                                         DIP_DE_category_plot,
                                         RS_DE_category_plot,
                                         nrow = 1)

if(exportFigs == TRUE) {
  ggsave(filename = paste("exported_figures/transgressive_expression_categories_mouse_logFC_", logFC_cutoff ,".pdf", sep = ""), 
         all_stages_DE_category_plot,
         width = 6.5, height = 2)
} else {
  all_stages_DE_category_plot
}

mouse_DE_categories <- data.frame(rbind(table(Hyb.Comb.SP.tt$category), table(Hyb.Comb.LZ.tt$category)))
mouse_DE_categories <- rbind(mouse_DE_categories, table(Hyb.Comb.DIP.tt$category))
mouse_DE_categories <- rbind(mouse_DE_categories, table(Hyb.Comb.RS.tt$category))
mouse_DE_categories$stage <- c("SP", "LZ", "DIP", "RS")
mouse_DE_categories$species <- c(rep("mouse", 4))  
mouse_DE_categories$perc_transgressive <- round(100*mouse_DE_categories$transgressive/
                                                  rowSums(mouse_DE_categories[,1:2]),1)
mouse_DE_categories$perc_intermediate <- round(100*mouse_DE_categories$intermediate/
                                                 rowSums(mouse_DE_categories[,1:2]),1)

mouse_DE_categories

write.csv(mouse_DE_categories, 
          paste("exported_files/mouse_DE_gene_category_counts_logFC_", logFC_cutoff,".csv", sep = ""))
```

```{r all-DE-category-plot}
#write DE gene categories out to exported files and mouse processing folder
write.csv(Hyb.Comb.SP.tt,  paste("exported_files/hybrid_mouse_Comb_SP_DE_Genes_wCategories_logFC_", logFC_cutoff ,".csv", sep = ""))
write.csv(Hyb.Comb.LZ.tt,  paste("exported_files/hybrid_mouse_Comb_LZ_DE_Genes_wCategories_logFC_", logFC_cutoff ,".csv", sep = ""))
write.csv(Hyb.Comb.DIP.tt, paste("exported_files/hybrid_mouse_Comb_DIP_DE_Genes_wCategories_logFC_", logFC_cutoff ,".csv", sep = ""))
write.csv(Hyb.Comb.RS.tt,  paste("exported_files/hybrid_mouse_Comb_RS_DE_Genes_wCategories_logFC_", logFC_cutoff ,".csv", sep = ""))

#print DE summary stats; specifically, numbers of DE genes for different contrasts
#transgressive DEs
print(paste("There are ", dim(Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$category == "transgressive",])[1],
            " genes transgressively differentially expressed in spermatogonia between hybrids and both parents", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$category == "transgressive",])[1],
            " genes transgressively differentially expressed in leptotene/zygotene between hybrids and both parents", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$category == "transgressive",])[1],
            " genes transgressively differentially expressed in diplotene between hybrids and both parents", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$category == "transgressive",])[1],
            " genes transgressively differentially expressed in round spermatids between hybrids and both parents", 
            sep = ""))

#print DE summary stats; specifically, numbers of DE genes for different contrasts
#same X DE genes
print(paste("There are ", dim(Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$category == "sameX_only",])[1],
            " genes differentially expressed in spermatogonia between hybrids and parent with same X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$category == "sameX_only",])[1],
            " genes differentially expressed in leptotene/zygotene between hybrids and parent with same X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$category == "sameX_only",])[1],
            " genes differentially expressed in diplotene between hybrids and parent with same X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$category == "sameX_only",])[1],
            " genes differentially expressed in round spermatids between hybrids and parent with same X", 
            sep = ""))

#print DE summary stats; specifically, numbers of DE genes for different contrasts
#different X DE genes
print(paste("There are ", dim(Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$category == "diffX_only",])[1],
            " genes differentially expressed in spermatogonia between hybrids and parent with different X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$category == "diffX_only",])[1],
            " genes differentially expressed in leptotene/zygotene between hybrids and parent with different X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$category == "diffX_only",])[1],
            " genes differentially expressed in diplotene between hybrids and parent with different X", 
            sep = ""))
print(paste("There are ", dim(Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$category == "diffX_only",])[1],
            " genes differentially expressed in round spermatids between hybrids and parent with different X", 
            sep = ""))

Mouse.SP.DE <- Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$sig_in_both == "yes",]
Mouse.LZ.DE <- Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$sig_in_both == "yes",]
Mouse.DIP.DE <- Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$sig_in_both == "yes",]
Mouse.RS.DE <- Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$sig_in_both == "yes",]

Mouse.SP.trans <- Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$category == "transgressive",]
Mouse.LZ.trans <- Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$category == "transgressive",]
Mouse.DIP.trans <- Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$category == "transgressive",]
Mouse.RS.trans <- Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$category == "transgressive",]

Mouse.SP.inter <- Hyb.Comb.SP.tt[Hyb.Comb.SP.tt$category == "intermediate",]
Mouse.LZ.inter <- Hyb.Comb.LZ.tt[Hyb.Comb.LZ.tt$category == "intermediate",]
Mouse.DIP.inter <- Hyb.Comb.DIP.tt[Hyb.Comb.DIP.tt$category == "intermediate",]
Mouse.RS.inter <- Hyb.Comb.RS.tt[Hyb.Comb.RS.tt$category == "intermediate",]

#write mouse trans DE gene info out to files for post-analysis in processing
write.csv(Mouse.SP.trans, "circos_processing_scripts/mouse_circos_hybrids/data/hybrid_mouse_trans_SP_DE_Genes.csv")
write.csv(Mouse.LZ.trans, "circos_processing_scripts/mouse_circos_hybrids/data/hybrid_mouse_trans_LZ_DE_Genes.csv")
write.csv(Mouse.DIP.trans, "circos_processing_scripts/mouse_circos_hybrids/data/hybrid_mouse_trans_DIP_DE_Genes.csv")
write.csv(Mouse.RS.trans, "circos_processing_scripts/mouse_circos_hybrids/data/hybrid_mouse_trans_RS_DE_Genes.csv")
```

<h3>Compare how overexpressed the X chromosome is during diplotene in house mice and hamsters</h3>
```{r X-over-expression-in-diplotene} 
#the goal of this analysis is to calculate the average (+/- SEM) relative overexpression of autosomal and X linked genes for each stage in hybrids and in parents
#set up rowMeans for stage x genotype x chromosome type for MSHyb
rpkm_MSHyb_SP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_SP_allAuto.norm))
colnames(rpkm_MSHyb_SP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MSHyb_SP_justX.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_SP_justX.norm))
colnames(rpkm_MSHyb_SP_justX.norm.mean) <- "mean_FPKM"

rpkm_MSHyb_LZ_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_LZ_allAuto.norm))
colnames(rpkm_MSHyb_LZ_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MSHyb_LZ_justX.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_LZ_justX.norm))
colnames(rpkm_MSHyb_LZ_justX.norm.mean) <- "mean_FPKM"

rpkm_MSHyb_DIP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_DIP_allAuto.norm))
colnames(rpkm_MSHyb_DIP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MSHyb_DIP_justX.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_DIP_justX.norm))
colnames(rpkm_MSHyb_DIP_justX.norm.mean) <- "mean_FPKM"

rpkm_MSHyb_RS_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_RS_allAuto.norm))
colnames(rpkm_MSHyb_RS_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MSHyb_RS_justX.norm.mean <- data.frame(rowMeans(rpkm_MSHyb_RS_justX.norm))
colnames(rpkm_MSHyb_RS_justX.norm.mean) <- "mean_FPKM"


#set up rowMeans for stage x genotype x chromosome type for MusP
rpkm_MusP_SP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MusP_SP_allAuto.norm))
colnames(rpkm_MusP_SP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MusP_SP_justX.norm.mean <- data.frame(rowMeans(rpkm_MusP_SP_justX.norm))
colnames(rpkm_MusP_SP_justX.norm.mean) <- "mean_FPKM"

rpkm_MusP_LZ_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MusP_LZ_allAuto.norm))
colnames(rpkm_MusP_LZ_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MusP_LZ_justX.norm.mean <- data.frame(rowMeans(rpkm_MusP_LZ_justX.norm))
colnames(rpkm_MusP_LZ_justX.norm.mean) <- "mean_FPKM"

rpkm_MusP_DIP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MusP_DIP_allAuto.norm))
colnames(rpkm_MusP_DIP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MusP_DIP_justX.norm.mean <- data.frame(rowMeans(rpkm_MusP_DIP_justX.norm))
colnames(rpkm_MusP_DIP_justX.norm.mean) <- "mean_FPKM"

rpkm_MusP_RS_allAuto.norm.mean <- data.frame(rowMeans(rpkm_MusP_RS_allAuto.norm))
colnames(rpkm_MusP_RS_allAuto.norm.mean) <- "mean_FPKM"
rpkm_MusP_RS_justX.norm.mean <- data.frame(rowMeans(rpkm_MusP_RS_justX.norm))
colnames(rpkm_MusP_RS_justX.norm.mean) <- "mean_FPKM"


#set up rowMeans for stage x genotype x chromosome type for DomP
rpkm_DomP_SP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_DomP_SP_allAuto.norm))
colnames(rpkm_DomP_SP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_DomP_SP_justX.norm.mean <- data.frame(rowMeans(rpkm_DomP_SP_justX.norm))
colnames(rpkm_DomP_SP_justX.norm.mean) <- "mean_FPKM"

rpkm_DomP_LZ_allAuto.norm.mean <- data.frame(rowMeans(rpkm_DomP_LZ_allAuto.norm))
colnames(rpkm_DomP_LZ_allAuto.norm.mean) <- "mean_FPKM"
rpkm_DomP_LZ_justX.norm.mean <- data.frame(rowMeans(rpkm_DomP_LZ_justX.norm))
colnames(rpkm_DomP_LZ_justX.norm.mean) <- "mean_FPKM"

rpkm_DomP_DIP_allAuto.norm.mean <- data.frame(rowMeans(rpkm_DomP_DIP_allAuto.norm))
colnames(rpkm_DomP_DIP_allAuto.norm.mean) <- "mean_FPKM"
rpkm_DomP_DIP_justX.norm.mean <- data.frame(rowMeans(rpkm_DomP_DIP_justX.norm))
colnames(rpkm_DomP_DIP_justX.norm.mean) <- "mean_FPKM"

rpkm_DomP_RS_allAuto.norm.mean <- data.frame(rowMeans(rpkm_DomP_RS_allAuto.norm))
colnames(rpkm_DomP_RS_allAuto.norm.mean) <- "mean_FPKM"
rpkm_DomP_RS_justX.norm.mean <- data.frame(rowMeans(rpkm_DomP_RS_justX.norm))
colnames(rpkm_DomP_RS_justX.norm.mean) <- "mean_FPKM"


#calculate the variance in X-linked overexpression; produces Figure S9
#creates a data frame that contains the average relative amount of X-linked overexpression in each diplotene individual
avg_overExpression_DIP_justX <- data.frame(overExp = 
                                             c(colMeans(rpkm_MusP_DIP_justX.norm)/mean(rpkm_MusP_DIP_justX.norm.mean$mean_FPKM),
                                               colMeans(rpkm_MSHyb_DIP_justX.norm)/mean(rpkm_MusP_DIP_justX.norm.mean$mean_FPKM),
                                               colMeans(rpkm_DomP_DIP_justX.norm)/mean(rpkm_MusP_DIP_justX.norm.mean$mean_FPKM)))
avg_overExpression_DIP_justX$ID <- gsub("-DIP", "", rownames(avg_overExpression_DIP_justX))
avg_overExpression_DIP_justX$Strain <- factor(gsub("-.*", "", avg_overExpression_DIP_justX$ID), levels = c("MusP", "MSHyb", "DomP"))

#creates a data frame that contains the SEM of the relative amount of X-linked overexpression in each diplotene individual
var_overExpression_DIP_justX <- 
  data.frame(Strain = c("MusP", "MSHyb", "DomP"),
             Var = c(calculate_sem(subset(avg_overExpression_DIP_justX,
                                          avg_overExpression_DIP_justX$Strain == "MusP")$overExp),
                     calculate_sem(subset(avg_overExpression_DIP_justX, 
                                          avg_overExpression_DIP_justX$Strain == "MSHyb")$overExp),
                     calculate_sem(subset(avg_overExpression_DIP_justX, 
                                          avg_overExpression_DIP_justX$Strain == "DomP")$overExp)))

#plots the amount of X-linked over-expression in each diplotene sample
overExp_justX_variance_plot <- 
  ggplot(avg_overExpression_DIP_justX, aes(x=Strain, y = overExp, 
                                           shape = Strain, col = Strain, fill = Strain)) + 
  geom_quasirandom(aes(fill = Strain, color = Strain, shape = Strain), alpha = 1, size = 0.75) +
  geom_boxplot(width=0.1, outlier.shape = NA, lwd = 0.2, alpha = 0.2, color = "black") +
  scale_fill_manual(values=c(gray_5, gray_4, gray_2)) + 
  scale_color_manual(values=c(gray_5, gray_4, gray_2)) + 
  scale_shape_manual(values=c(24,4,25)) + 
  theme_bw() + 
  theme(legend.position = "none", 
        text = element_text(size = 6),
        axis.title.x=element_blank(), 
        axis.title.y = element_text(size = 6), 
        axis.text.x = element_text(angle = 45, vjust = 0.8, size = 6), 
        plot.margin = unit(c(0.4, 0.07, 0, 0.07), "cm"), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line.y = element_line(colour = "black", linewidth = 0.2), 
        panel.border = element_blank(), 
        axis.ticks.length.x = unit(0, "cm")) +
  scale_x_discrete(labels = c("mus", "Hybrid", "dom")) + ylab("Relative X Overexpression") + 
  geom_signif(
    y_position = c(summary(avg_overExpression_DIP_justX[avg_overExpression_DIP_justX$Strain == "MusP",]$overExp)[6]+2,
                   summary(avg_overExpression_DIP_justX[avg_overExpression_DIP_justX$Strain == "MSHyb",]$overExp)[6]+2,
                   summary(avg_overExpression_DIP_justX[avg_overExpression_DIP_justX$Strain == "DomP",]$overExp)[6]+2), 
    xmin = c(1,2,3), 
    xmax = c(1,2,3), 
    annotation = c(paste("SEM = ", round(var_overExpression_DIP_justX[1,2],2)),
                   paste("SEM = ", round(var_overExpression_DIP_justX[2,2],2)),
                   paste("SEM = ", round(var_overExpression_DIP_justX[3,2],2))), 
    tip_length = 0, textsize = sigText_size, size = 0) +
  ylim(values = c(0,36))


#calculate the variance in autosomal overexpression; produces Figure S9
#creates a data frame that contains the average relative amount of autosomal overexpression in each diplotene individual
avg_overExpression_DIP_allAuto <- data.frame(overExp = 
                                               c(colMeans(rpkm_MusP_DIP_allAuto.norm)/mean(rpkm_MusP_DIP_allAuto.norm.mean$mean_FPKM),
                                                 colMeans(rpkm_MSHyb_DIP_allAuto.norm)/mean(rpkm_MusP_DIP_allAuto.norm.mean$mean_FPKM),
                                                 colMeans(rpkm_DomP_DIP_allAuto.norm)/mean(rpkm_MusP_DIP_allAuto.norm.mean$mean_FPKM)))
avg_overExpression_DIP_allAuto$ID <- gsub("-DIP", "", rownames(avg_overExpression_DIP_allAuto))
avg_overExpression_DIP_allAuto$Strain <- factor(gsub("-.*", "", avg_overExpression_DIP_allAuto$ID), levels = c("MusP", "MSHyb", "DomP"))

#creates a data frame that contains the SEM of the relative amount of autosomal overexpression in each diplotene individual
var_overExpression_DIP_allAuto <- 
  data.frame(Strain = c("MusP", "MSHyb", "DomP"),
             Var = c(calculate_sem(subset(avg_overExpression_DIP_allAuto,
                                          avg_overExpression_DIP_allAuto$Strain == "MusP")$overExp),
                     calculate_sem(subset(avg_overExpression_DIP_allAuto, 
                                          avg_overExpression_DIP_allAuto$Strain == "MSHyb")$overExp),
                     calculate_sem(subset(avg_overExpression_DIP_allAuto, 
                                          avg_overExpression_DIP_allAuto$Strain == "DomP")$overExp)))

#plots the amount of autosomal over-expression in each diplotene sample
overExp_allAuto_variance_plot <- 
  ggplot(avg_overExpression_DIP_allAuto, aes(x=Strain, y = overExp, 
                                             shape = Strain, col = Strain, fill = Strain)) + 
  geom_quasirandom(aes(fill = Strain, color = Strain, shape = Strain), alpha = 1, size = 0.75) +
  geom_boxplot(width=0.1, outlier.shape = NA, lwd = 0.2, alpha = 0.2, color = "black") +
  scale_fill_manual(values=c(gray_5, gray_4, gray_2)) + 
  scale_color_manual(values=c(gray_5, gray_4, gray_2)) + 
  scale_shape_manual(values=c(24,4,25)) + 
  theme_bw() + 
  theme(legend.position = "none", 
        text = element_text(size = 6),
        axis.title.x=element_blank(), 
        axis.title.y = element_text(size = 6), 
        axis.text.x = element_text(angle = 45, vjust = 0.8, size = 6), 
        plot.margin = unit(c(0.4, 0.07, 0, 0.07), "cm"), 
        panel.grid.major.x = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line.y = element_line(colour = "black", linewidth = 0.2), 
        panel.border = element_blank(), 
        axis.ticks.length.x = unit(0, "cm")) +
  scale_x_discrete(labels = c("mus", "Hybrid", "dom")) + ylab("Relative Auto Overexpression") + 
  geom_signif(
    y_position = c(summary(avg_overExpression_DIP_allAuto[avg_overExpression_DIP_allAuto$Strain == "MusP",]$overExp)[6]+2,
                   summary(avg_overExpression_DIP_allAuto[avg_overExpression_DIP_allAuto$Strain == "MSHyb",]$overExp)[6]+2,
                   summary(avg_overExpression_DIP_allAuto[avg_overExpression_DIP_allAuto$Strain == "DomP",]$overExp)[6]+2), 
    xmin = c(1,2,3), 
    xmax = c(1,2,3), 
    annotation = c(paste("SEM = ", round(var_overExpression_DIP_allAuto[1,2],2)),
                   paste("SEM = ", round(var_overExpression_DIP_allAuto[2,2],2)),
                   paste("SEM = ", round(var_overExpression_DIP_allAuto[3,2],2))), 
    tip_length = 0, textsize = sigText_size, size = 0) +
  ylim(values = c(0,36))

if(exportFigs == TRUE) {
  ggsave(filename = "exported_figures/X_and_auto_overexpression_mouse.pdf", 
         plot_grid(overExp_allAuto_variance_plot, overExp_justX_variance_plot, nrow = 1),
         width = 4, height = 0.75*half_plot_height)
} else {
  plot_grid(overExp_allAuto_variance_plot, overExp_justX_variance_plot, nrow = 1)
}

#print out the relative overexpression of the X during diplotene in hybrids relative to parents
avg_overExpression_DIP_justX %>% group_by(Strain) %>%
  summarize_at('overExp',mean)

#set up logFC expressed dataframes to test if X is statistically overexpressed relative to autosomes
#MSHyb - MusP
MSHyb_MusP_SP_allAuto.logFC.diff <- data.frame(logFC = Hyb.MusP.SP.tt$table[Hyb.MusP.SP.tt$table$chr != "X",]$logFC)
MSHyb_MusP_SP_justX.logFC.diff <-   data.frame(logFC = Hyb.MusP.SP.tt$table[Hyb.MusP.SP.tt$table$chr == "X",]$logFC)

MSHyb_MusP_LZ_allAuto.logFC.diff <- data.frame(logFC = Hyb.MusP.LZ.tt$table[Hyb.MusP.LZ.tt$table$chr != "X",]$logFC)
MSHyb_MusP_LZ_justX.logFC.diff <-   data.frame(logFC = Hyb.MusP.LZ.tt$table[Hyb.MusP.LZ.tt$table$chr == "X",]$logFC)

MSHyb_MusP_DIP_allAuto.logFC.diff <- data.frame(logFC = Hyb.MusP.DIP.tt$table[Hyb.MusP.DIP.tt$table$chr != "X",]$logFC)
MSHyb_MusP_DIP_justX.logFC.diff <-   data.frame(logFC = Hyb.MusP.DIP.tt$table[Hyb.MusP.DIP.tt$table$chr == "X",]$logFC)

#wilcoxon rank sum tests
x_vs_auto_pvalues <- data.frame(names = c("MSHyb_MusP_SP", "MSHyb_MusP_LZ", "MSHyb_MusP_DIP"),
                                pValues = c(wilcox.test(MSHyb_MusP_SP_justX.logFC.diff$logFC, 
                                                        MSHyb_MusP_SP_allAuto.logFC.diff$logFC)$p.value,
                                            wilcox.test(MSHyb_MusP_LZ_justX.logFC.diff$logFC, 
                                                        MSHyb_MusP_LZ_allAuto.logFC.diff$logFC)$p.value,
                                            wilcox.test(MSHyb_MusP_DIP_justX.logFC.diff$logFC,
                                                        MSHyb_MusP_DIP_allAuto.logFC.diff$logFC)$p.value))

x_vs_auto_pvalues$pValues <- signif(p.adjust(x_vs_auto_pvalues$pValues, method = "fdr"), 2)
x_vs_auto_pvalues$significant <- sig_conversion(x_vs_auto_pvalues$pValues)
```

<h3>Hybrids hypergeometric tests to test if different chromosomes are enriched for DEs</h3>
```{r hybrid-DE-hypergeometric-tests}
enrichment_FDR <- 0.05

#set the list of chromosomes to iterate over
chr_list <<- chrom_key$chromosome

#create two functions: the first performs a hypergeometric test for the distribution of 
test_each_genomic_interval <- function(chromosome) {
  
  #hypergeometric tests should take the form of:
  #phyper(Overlap, group2, Total-group2, group1, lower.tail=TRUE) for depletion
  #phyper(Overlap - 1, group2, Total-group2, group1, lower.tail=FALSE) for enrichment
  
  #where:
  #Total = expressed genes on all chromosomes for appropriate contrast: exp_genes_on_chr
  #Group1 = expressed genes on given chromosome for appropriate contrast: exp_genes_on_chr
  #Group2 = all DE genes across chromosomes for appropriate contrast: all_DE_genes
  #Overlap = DE genes on given chromosome for appropriate contrast: DE_on_chr
  DE_on_chr <- dim(example_de[example_de$chr == chromosome,])[1]
  all_DE_genes <- dim(example_de)[1]
  all_expressed_genes <- length(example_exp)
  non_DE_genes <- all_expressed_genes - all_DE_genes
  exp_genes_on_chr <- sum(example_exp %in% annotations[annotations$chr == chromosome,]$gene)
  
  #run phyper tests
  under.p <- phyper(DE_on_chr, all_DE_genes, non_DE_genes, exp_genes_on_chr, lower.tail = TRUE)
  over.p <- phyper(DE_on_chr - 1, all_DE_genes, non_DE_genes, exp_genes_on_chr, lower.tail = FALSE)
  
  #round p-values to 5 digits
  under <- round(under.p, digits = 5)
  over <- round(over.p, digits = 5)
  
  #calculate number of observed and expected genes
  exp <- round((all_DE_genes/all_expressed_genes)*exp_genes_on_chr,digits = 0)
  obs <- DE_on_chr
  
  #return the depletion and enrichment pvalues plus the exp and obs number of genes
  return(c(under, over, exp, obs))
}

test_for_DE_enrichment <- function(stage, DE_type) {
  
  #get the relevant DE object for the given stage and type of DE gene (all, transgressive, intermediate)
  example_de <<- get(ls(pattern = paste("Mouse", stage, DE_type, sep = "\\."), envir = .GlobalEnv))
  
  #retrieve the list of genes expressed in the given contrast as the background
  example_exp <<- get(ls(pattern = paste("Hyb_Comb_", stage, "_exp", sep = ""), envir = .GlobalEnv))
  
  #call chr interval
  results_df <- data.frame(do.call(rbind,lapply(chrom_key$chr, test_each_genomic_interval)))
  
  
  #add formatting to the hypergeometric test data frame
  colnames(results_df) <- c("under_p_adjust", "over_p_adjust", "exp", "obs")
  rownames(results_df) <- chr_list
  results_df$chr <- chr_list
  
  #assign the data frame to a globally accessible object
  assign(paste("Mouse", stage, DE_type, "enrichment_df", sep = "_"), results_df, envir = .GlobalEnv)
  
  #print the results about which chromosomes were depleted or enriched
  return(writeLines(paste("For ", DE_type," genes during " ,stage, ": enriched chromosomes include: ", 
                          paste(rownames(results_df)[results_df$over_p_adjust < 0.05], collapse = ", "), 
                          "\n", "For ", DE_type," genes during " ,stage, ": depleted chromosomes include: ", 
                          paste(rownames(results_df)[results_df$under_p_adjust < 0.05], collapse = ", "), "\n", 
                          sep = "")))
}

#apply hypergeometric tests to DE genes from all stages
mapply(test_for_DE_enrichment,
       c("SP", "LZ", "DIP", "RS", "SP", "LZ", "DIP", "RS", "SP", "LZ", "DIP", "RS"),
       c("DE", "DE", "DE", "DE", "trans", "trans", "trans", "trans", "inter", "inter", "inter", "inter"))

#a function to reformat an enrichment data frame to be compatibile with the processing circos diagram script
reformat_enrichment_df_for_processing <- function(enrich_df) {
  #retrieve data frame
  enrichment_df <- get(enrich_df)
  
  #initialize blank columns
  enrichment_df$enriched <- ""
  enrichment_df$direction <- ""
  enrichment_df$sig <- ""
  enrichment_df$ringText <- ""
  
  #column indicating if there is enrichment or depletion
  if(sum(enrichment_df$under_p_adjust < 0.05 | enrichment_df$over_p_adjust < 0.05) > 0) {
    enrichment_df[enrichment_df$under_p_adjust < 0.05 | enrichment_df$over_p_adjust < 0.05,]$enriched <- "yes"
  }
  
  #if depletion exists, then add in all the information about significance
  if(sum(enrichment_df$under_p_adjust < 0.05) > 0) {
    enrichment_df[enrichment_df$under_p_adjust < 0.05 & enrichment_df$enriched == "yes",]$direction <- "(-)"
    enrichment_df[enrichment_df$direction == "(-)",]$sig <- sig_conversion(enrichment_df[enrichment_df$direction == "(-)",]$under_p_adjust)
    enrichment_df[enrichment_df$direction == "(-)",]$ringText <- gsub("\\*", "- ", enrichment_df[enrichment_df$direction == "(-)",]$sig)
  }
  
  #if enrichment exists, then add in all the information about significance
  if(sum(enrichment_df$over_p_adjust < 0.05) > 0) {
    enrichment_df[enrichment_df$under_p_adjust > 0.05 & enrichment_df$enriched == "yes",]$direction <- "(+)"
    enrichment_df[enrichment_df$direction == "(+)",]$sig <- sig_conversion(enrichment_df[enrichment_df$direction == "(+)",]$over_p_adjust)
    enrichment_df[enrichment_df$direction == "(+)",]$ringText <- gsub("\\*", "+", enrichment_df[enrichment_df$direction == "(+)",]$sig)
  }
  
  #remove the extra space that the depletion code ads
  enrichment_df$ringText <- gsub(" $", "", enrichment_df$ringText)
  
  
  #uncomment if you want to create a new data frame with the reformatting
  #assign(paste(enrich_df, "_for_processing", sep = ""), enrichment_df, envir = .GlobalEnv)
  
  #save to file for use in processing scripts
  write.csv(enrichment_df, 
            file = paste("circos_processing_scripts/mouse_circos_hybrids/data/", 
                         paste(unlist(strsplit(enrich_df, split = "_"))[1:2], collapse = "."),
                         "_sig.csv", sep = ""), row.names = FALSE)
}

#apply reformatting to all enrichment data frames
invisible(lapply(c("Mouse_SP_trans_enrichment_df",
                   "Mouse_LZ_trans_enrichment_df",
                   "Mouse_DIP_trans_enrichment_df",
                   "Mouse_RS_trans_enrichment_df"), 
                 reformat_enrichment_df_for_processing))
```

<h3>BCV for each Species/Hybrid</h3>
```{r calculate-BCV-for-each-mouse-cross}
#the purpose of this analysis is to see how variation within hybrids and within parents compares
#variation across hybrids for SP/LZ/DIP
dgeMSHybDev <- DGEList(just_counts[,grep("MSHyb-.*-[D,S,L]",colnames(just_counts))], genes=annotations, group=grep("MSHyb-[D,S,L]",metadata$condition_name, value = TRUE))
dgeMSHybDev <- normalize_dge(dgeMSHybDev)

#variation across hybrids for SP/LZ/DIP
design_MSHybDev <- design[grep("MSHyb\\.[D,L,S]", design$condition_name),]
design_MSHybDev$condition_name <- factor(design_MSHybDev$condition_name)

design_MSHybDev_Matrix  <-  model.matrix(~0+design_MSHybDev$condition_name)
colnames(design_MSHybDev_Matrix)  <-  levels(design_MSHybDev$condition_name)
rownames(design_MSHybDev_Matrix)  <-  design_MSHybDev$sample_ID

dgeMSHybDev <-  estimateGLMCommonDisp(dgeMSHybDev, design_MSHybDev_Matrix, verbose = TRUE)
dgeMSHybDev <- estimateGLMTrendedDisp(dgeMSHybDev, design_MSHybDev_Matrix) 
dgeMSHybDev <- estimateGLMTagwiseDisp(dgeMSHybDev, design_MSHybDev_Matrix)  # estimate genewise dispersion


#change exportFigs to TRUE to export as PDF if desired
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Dispersion_plots_justMSHyb_dataset.pdf", width=10, height=8, pointsize=12)
  plotBCV(dgeMSHybDev, main = paste("Dispersion estimates for MSHyb dataset; BCV = ",round(sqrt(dgeMSHybDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
  dev.off()
}
plotBCV(dgeMSHybDev, main = paste("Dispersion estimates for MSHyb dataset; BCV = ",round(sqrt(dgeMSHybDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)


#variation across M. m. dom for SP/LZ/DIP
dgeMusPDev <- DGEList(just_counts[,grep("MusP-.*-[D,S,L]",colnames(just_counts))], genes=annotations, group=grep("MusP-[D,S,L]",metadata$condition_name, value = TRUE))
dgeMusPDev <- normalize_dge(dgeMusPDev)

#variation across M. m. dom for SP/LZ/DIP
design_MusPDev <- design[grep("MusP\\.[D,L,S]", design$condition_name),]
design_MusPDev$condition_name <- factor(design_MusPDev$condition_name)

design_MusPDev_Matrix  <-  model.matrix(~0+design_MusPDev$condition_name)
colnames(design_MusPDev_Matrix)  <-  levels(design_MusPDev$condition_name)
rownames(design_MusPDev_Matrix)  <-  design_MusPDev$sample_ID

dgeMusPDev <-  estimateGLMCommonDisp(dgeMusPDev, design_MusPDev_Matrix, verbose = TRUE)
dgeMusPDev <- estimateGLMTrendedDisp(dgeMusPDev, design_MusPDev_Matrix) 
dgeMusPDev <- estimateGLMTagwiseDisp(dgeMusPDev, design_MusPDev_Matrix)  # estimate genewise dispersion


#change exportFigs to TRUE to export as PDF if desired
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Dispersion_plots_justMusP_dataset.pdf", width=10, height=8, pointsize=12)
  plotBCV(dgeMusPDev, main = paste("Dispersion estimates for MusP dataset; BCV = ",round(sqrt(dgeMusPDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
  dev.off()
}
plotBCV(dgeMusPDev, main = paste("Dispersion estimates for MusP dataset; BCV = ",round(sqrt(dgeMusPDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)


#variation across M. m. mus for SP/LZ/DIP
dgeDomPDev <- DGEList(just_counts[,grep("DomP-.*-[D,S,L]",colnames(just_counts))], genes=annotations, group=grep("DomP-[D,S,L]",metadata$condition_name, value = TRUE))
dgeDomPDev <- normalize_dge(dgeDomPDev)

#variation across M. m. mus for SP/LZ/DIP
design_DomPDev <- design[grep("DomP\\.[D,L,S]", design$condition_name),]
design_DomPDev$condition_name <- factor(design_DomPDev$condition_name)

design_DomPDev_Matrix  <-  model.matrix(~0+design_DomPDev$condition_name)
colnames(design_DomPDev_Matrix)  <-  levels(design_DomPDev$condition_name)
rownames(design_DomPDev_Matrix)  <-  design_DomPDev$sample_ID

dgeDomPDev <-  estimateGLMCommonDisp(dgeDomPDev, design_DomPDev_Matrix, verbose = TRUE)
dgeDomPDev <- estimateGLMTrendedDisp(dgeDomPDev, design_DomPDev_Matrix) 
dgeDomPDev <- estimateGLMTagwiseDisp(dgeDomPDev, design_DomPDev_Matrix)  # estimate genewise dispersion


#change exportFigs to TRUE to export as PDF if desired
if(exportFigs == TRUE) {
  pdf(file="exported_figures/Dispersion_plots_justDomP_dataset.pdf", width=10, height=8, pointsize=12)
  plotBCV(dgeDomPDev, main = paste("Dispersion estimates for DomP dataset; BCV = ",round(sqrt(dgeDomPDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
  dev.off()
}
plotBCV(dgeDomPDev, main = paste("Dispersion estimates for DomP dataset; BCV = ",round(sqrt(dgeDomPDev$common.dispersion), 3)), ylim = c(0, 12), col.common = "#C2A5A2", col.trend = "#745756", xlab = "Average log(CPM)", xlim = c(-4,13), col = alpha("#6E6E6E", 0.15), cex = 1.25)
```
